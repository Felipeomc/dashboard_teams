<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard BN — Team Fit (AT/AC/AE)</title>
  <style>
    :root{
      --bg:#ffffff; --card:#ffffff; --card2:#f6f8fb; --text:#0b1220; --muted:#4b5563;
      --line:#d7dde6; --accent:#2f6bff; --good:#1f9d55; --warn:#b45309; --bad:#b42318;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --r: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:var(--sans); background:var(--bg); color:var(--text);}
    header{padding:10px 14px 6px; position:sticky; top:0; background:rgba(255,255,255,.92); backdrop-filter: blur(8px); border-bottom:1px solid var(--line); z-index:10}
    h1{font-size:16px; margin:0 0 6px; font-weight:700; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px; margin:0}
    .wrap{padding:16px 18px 26px; max-width:1300px; margin:0 auto;}
    .grid{display:grid; gap:14px;}
    @media(min-width:1100px){ .grid{grid-template-columns: 1fr;} }
    .card{background:var(--card); border:1px solid var(--line); border-radius:var(--r); box-shadow:var(--shadow);}
    .card .hd{padding:12px 12px 10px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; justify-content:space-between}
    .card .hd strong{font-size:13px}
    .card .bd{padding:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{font-family:var(--mono); font-size:12px; color:var(--muted); border:1px solid var(--line); padding:6px 8px; border-radius:999px; background:var(--card2)}
    .btn{cursor:pointer; border:1px solid var(--line); background:linear-gradient(180deg,#ffffff, #f3f4f6);
         color:var(--text); padding:8px 10px; border-radius:12px; font-size:12px; font-weight:600;}
    .btn:hover{border-color:#2f425f}
    .btn:active{transform:translateY(1px)}
    input[type=file]{display:none}
    label.file{display:inline-flex; gap:8px; align-items:center}
    select{background:#ffffff; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:8px 10px; font-size:12px}
    .hint{color:var(--muted); font-size:12px; line-height:1.45; margin-top:8px}
    .kpis{
      display:flex;
      gap:12px;
      align-items:stretch;
      flex-wrap:nowrap;      /* não quebra linha */
    }

    .kpi{
      flex:1 1 0;            /* deixa os 3 dividirem o espaço */
      min-width:0;           /* IMPORTANTE: permite encolher */
    }
    .kpi{
      background:var(--card2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;

      display:grid;
      grid-template-columns: 1fr auto auto; /* titulo | valor | tier */
      align-items:baseline;
      column-gap:14px;
    }
    .kpi .t{font-size:12px; color:var(--muted); margin-bottom:6px}
    .kpi .v{font-family:var(--mono); font-size:16px; font-weight:700}
    .kpi .s{font-size:12px; color:var(--muted); margin-top:2px}
    .split{display:grid; gap:12px}
    @media(min-width:900px){ .split{grid-template-columns: 1fr 1fr;} }
    .svgbox{width:100%; overflow:auto; padding:8px 8px 2px}
    .mini{font-size:12px; color:var(--muted)}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{border-bottom:1px solid var(--line); padding:8px 6px; text-align:left; vertical-align:top}
    th{font-size:12px; color:var(--muted); font-weight:700}
    td code{font-family:var(--mono); font-size:12px; color:#0b1220}
    .barwrap{display:grid; gap:10px}
    .grid2{display:grid; gap:10px}
    @media(min-width:980px){
      .grid2{grid-template-columns: repeat(3, minmax(0,1fr)); align-items:start;}
      /* 4º card (Dom/Eco/Ling/PC) ocupa a linha inteira */
      .grid2 > .barcard:nth-child(4){grid-column:1 / -1;}
    }
    @media(min-width:700px) and (max-width:979px){
      .grid2{grid-template-columns: 1fr 1fr;}
      /* deixa AE ocupar a linha inteira para não esmagar */
      .grid2 > .barcard:nth-child(3){grid-column:1 / -1;}
      .grid2 > .barcard:nth-child(4){grid-column:1 / -1;}
    }

    .barcard{background:var(--card2); border:1px solid var(--line); border-radius:14px; padding:10px}
    .barcard .ttl{display:flex; justify-content:space-between; align-items:baseline; gap:10px}
    .barcard .ttl strong{font-size:12px}
    .barcard .ttl span{font-family:var(--mono); font-size:12px; color:var(--muted)}
    .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
    .leg{display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted)}
    .sw{width:10px; height:10px; border-radius:3px; background:#999}
    .foot{color:var(--muted); font-size:12px; margin-top:10px}
    .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    .mono{font-family:var(--mono)}
    .err{background:rgba(255,107,107,.08); border:1px solid rgba(255,107,107,.35); color:#0b1220; padding:10px; border-radius:14px; font-size:12px}
    .note{background:rgba(122,162,255,.08); border:1px solid rgba(122,162,255,.35); color:#0b1220; padding:10px; border-radius:14px; font-size:12px}
  
    /* Tooltip flutuante */
    .tooltip{
      position:fixed;
      pointer-events:none;
      z-index:9999;
      max-width:420px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#ffffff;
      color:var(--text);
      box-shadow: 0 12px 28px rgba(16,24,40,.18);
      font-size:12px;
      line-height:1.35;
      display:none;
    }
    .tooltip .tt-title{font-weight:800; margin-bottom:6px;}
    .formulaTag{cursor:help; text-decoration:underline; text-underline-offset:2px;}
    .tooltip .tt-mono{font-family:var(--mono); font-size:12px; color:var(--text); background:#f6f8fb; border:1px solid var(--line); padding:6px 8px; border-radius:12px; display:inline-block;}
    .tooltip .tt-muted{color:var(--muted); font-size:12px; margin-top:6px;}
    #bnGraphWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:16px;
      background:#f8fafc;
      padding:10px;
      .detailsBox{
        margin-top:10px;
        border:1px solid var(--line);
        border-radius:14px;
        background:var(--card2);
        padding:12px;
      }
      .detailsBox .pre{white-space:pre-wrap; margin:0; font-family:var(--mono); font-size:12px; line-height:1.35;}
      .detailsBox .dt-label{font-size:12px; color:var(--muted); margin-bottom:4px; font-weight:700;}

    }
#bnGraph{ display:block; }
/* =======================
   STRIP FIXO (Projeto)
   ======================= */
.projectStrip{margin-top:6px; display:flex; gap:10px; align-items:stretch;}
@media(max-width:1000px){ .projectStrip{flex-direction:column;} }

.stripCard{
  background:var(--card2);
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px;
  min-width:0;
}

.stripTitle{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  font-size:12px;
  color:var(--muted);
  margin-bottom:8px;
}

.covRows{display:grid; gap:4px;}
.covRow{display:grid; grid-template-columns: 54px 1fr; gap:4px; align-items:flex-start;}
.covRow .dim{font-weight:900; font-size:12px; letter-spacing:.1px;}

.covStack{display:grid; gap:0px;}
.hbarLine{display:grid; grid-template-columns: 26px 1fr auto; gap:1px; align-items:center;}
.hbar{
  height:10px;
  background:#fff;
  border:1px solid var(--line);
  border-radius:999px;
  overflow:hidden;
}
.hbar > span{
  display:block; height:100%; width:0%;
  background:linear-gradient(90deg, rgba(47,107,255,.25), rgba(47,107,255,.85));
}
.hbarLine[data-kind="S"] .hbar > span{background:linear-gradient(90deg, rgba(31,157,85,.18), rgba(31,157,85,.75));}
.hbarLine[data-kind="C"] .hbar > span{background:linear-gradient(90deg, rgba(180,83,9,.18), rgba(180,83,9,.75));}
.hbarMeta{font-family:var(--mono); font-size:12px; color:var(--muted); white-space:nowrap;}

.techHint{font-size:12px; color:var(--muted); margin-top:2px; line-height:1.25;}
.techHint b{color:var(--text); font-weight:800;}

/* Ranking board */
.rankBoard{display:flex; gap:10px; align-items:flex-end; overflow-x:auto; padding-bottom:4px;}
.teamCol{
  flex:0 0 128px;
  border:1px solid var(--line);
  background:#fff;
  border-radius:14px;
  padding:8px;
  cursor:pointer;
}
.teamCol:hover{border-color:#2f6bff;}
.teamCol.active{outline:2px solid rgba(47,107,255,.35); border-color:#2f6bff;}

.teamName{
  font-size:12px;
  font-weight:900;
  margin-bottom:4px;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.teamDevs{
  font-family:var(--mono);
  font-size:11px;
  color:var(--muted);
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  margin-bottom:8px;
}

.vbars{display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:end; height:92px;}
.vbarBox{
  position:relative;
  height:92px;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  border-radius:10px;
  background:linear-gradient(180deg,#ffffff,#f3f4f6);
  border:1px solid var(--line);
  overflow:hidden;
}
.vbar{position:absolute; bottom:0; left:0; right:0; height:0%; background:rgba(47,107,255,.85);}
.vbar.expert{background:rgba(75,85,99,.85);}

.vnum{
  position:relative;
  z-index:2;
  font-family:var(--mono);
  font-size:12px;
  font-weight:900;
  color:#0b1220;
  padding:2px 6px;
  border-radius:999px;
  background:rgba(255,255,255,.92);
  border:1px solid var(--line);
  margin-bottom:6px;
}

.vlab{font-size:12px; color:var(--muted); margin-top:6px; display:flex; justify-content:space-between;}
.vlab span{width:50%; text-align:center;}
.topbar{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:16px;
}

.topbar h1{
  margin:0;
}

.top-controls{
  margin-top:0 !important;     /* mata o inline margin-top:10px */
  display:flex;
  gap:12px;
  justify-content:flex-end;
}

.top-controls select{
  min-width:140px;             /* opcional */
}
/* ===== Compactar "Cobertura técnica" ===== */
#projectStrip .stripCard{
  padding: 6px 8px;     /* antes: 10px */
  border-radius: 12px;  /* opcional, mais compacto */
}

#projectStrip .stripTitle{
  margin-bottom: 4px;   /* antes: 8px */
  line-height: 1.1;
}

/* distância entre DOM / ECO / LING */
#projectStrip .covRows{ gap: 6px; }   /* antes: 10px */

/* bloco de cada dimensão */
#projectStrip .covRow{
  grid-template-columns: 44px 1fr; /* antes: 54px 1fr */
  gap: 3px;                        /* antes: 10px */
}

#projectStrip .covRow .dim{
  font-size: 11px;    /* antes: 12px */
  line-height: 1.1;
}

/* distância entre M / S / C dentro de cada dimensão */
#projectStrip .covStack{ gap: 0px; }  /* antes: 6px */

#projectStrip .hbarLine{
  grid-template-columns: 15px 1fr auto; /* antes: 26px 1fr auto */
  gap: 1px;                              /* antes: 8px */
}

#projectStrip .hbar{ height: 8px; }     /* antes: 10px */

#projectStrip .hbarMeta{
  font-size: 11px;   /* antes: 11px */
  line-height: 1.1;
}

/* linha "Coberto: ...  Redund.: ..." */
#projectStrip .techHint{
  margin-top: 0;     /* antes: 2px */
  font-size: 10px;   /* antes: 11px */
  line-height: 1.12;
}

/* ===== Radar (Spider) por equipe ===== */
.radarGrid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap:10px;
  margin-top:10px;
}
.radarItem{
  border:1px solid #e5e7eb;
  border-radius:12px;
  padding:10px;
  background:#fff;
  cursor:pointer;
  transition: transform .05s ease, box-shadow .05s ease;
}
.radarItem:hover{ transform: translateY(-1px); box-shadow:0 6px 18px rgba(15,23,42,.08); }
.radarItem.active{ outline:2px solid #7aa2ff; }
.radarHead{
  display:flex;
  align-items:center;
  gap:8px;
  margin-bottom:6px;
}
.radarHead .dot{
  width:10px;height:10px;border-radius:999px;display:inline-block;
}
.radarSvg{ width:100%; height:220px; display:block; }
.radarKpis{
  display:flex;
  gap:10px;
  justify-content:space-between;
  margin-top:4px;
  font-size:12px;
  color:#334155;
}
.radarKpis .k{ opacity:.90; margin-right:6px; }




/* ===== AFINAR Ranking (força override) ===== */
#rankBoard.rankBoard{ gap:8px !important; }



#rankBoard .teamCol{ flex:0 0 84px !important; }


#rankBoard .teamName{
  font-size:11px !important;
  margin-bottom:2px !important;  /* antes 4px */
}

#rankBoard .teamDevs{
  font-size:11px !important;
  margin-bottom:6px !important;  /* antes 8px */
}

#rankBoard .vbars{
  height:72px !important;        /* antes 92px */
  gap:6px !important;            /* antes 8px */
}

#rankBoard .vbarBox{
  height:60px !important;        /* antes 92px */
  border-radius:6px !important;  /* antes 10px */
}

#rankBoard .vnum{
  font-size:12px !important;     /* antes 12px */
  margin-bottom:4px !important;  /* antes 6px */
}

#rankBoard .vlab{
  font-size:12px !important;
  margin-top:4px !important;     /* antes 6px */
}





/* ===== Ranking: barras FINAS de verdade (container + badges sem sobrepor) ===== */
#rankBoard .vbars{
  display:grid !important;
  grid-template-columns: 18px 18px !important; /* <-- AQUI afina o container */
  justify-content:center !important;
  gap:6px !important;
  height:72px !important;
}

#rankBoard .vbarBox{
  width:18px !important;     /* <-- força a caixa da barra a ser fina */
  height:72px !important;
  padding:0 !important;
  overflow:hidden !important;
  box-sizing:border-box !important;
}

#rankBoard .vbar{
  left:0 !important;
  right:0 !important;
}

/* badge do número menor, sem “invadir” a coluna do lado */
#rankBoard .vnum{
  width:14px !important;
  height:14px !important;
  padding:0 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  font-size:12px !important;
  margin-bottom:3px !important;
  border-radius:999px !important;
  box-sizing:border-box !important;
}

/* ===== PATCH: ranking mais estreito + barras mais finas ===== */
#rankBoard.rankBoard{ gap:8px; }                 /* espaço entre cards (opcional) */

#rankBoard .teamCol{
  flex: 0 0 110px;                               /* <-- estreita o card (antes 128px) */
  padding: 6px;                                  /* <-- compacta */
  border-radius: 12px;
}

#rankBoard .vbars{
  display: grid;                                  /* garante que não vai sobrepor */
  grid-template-columns: 1fr 1fr;
  gap: 6px;                                       /* <-- espaço entre as 2 barras */
  height: 84px;                                   /* <-- altura total do miolo */
}

#rankBoard .vbarBox{
  height: 84px;                                   /* tem que bater com .vbars */
  border-radius: 10px;
  overflow: hidden;                               /* garante que nada “vaza” */
}

/* AQUI é onde você “afina” a barra de verdade (o azul/cinza) */
#rankBoard .vbar{
  left: 10px;                                     /* <-- afina (antes 0) */
  right: 10px;                                    /* <-- afina (antes 0) */
  border-radius: 999px 999px 0 0;                 /* opcional, topo arredondado */
}

#rankBoard .vnum{ font-size: 12px; margin-bottom: 5px; }
#rankBoard .teamDevs{ margin-bottom: 6px; }


.tierRow{display:flex; align-items:center; gap:10px; margin-top:6px}
.tierTag{min-width:34px; text-align:center; padding:2px 8px; border-radius:999px; border:1px solid var(--line); background:#fff}
.tierTrack{flex:1; height:10px; background:#eef2ff; border-radius:999px; overflow:hidden}
.tierFill{height:100%; background:linear-gradient(90deg,#7aa2ff,#4f7dff); border-radius:999px}
.tierPct{min-width:42px; text-align:right}
.splitFull{grid-template-columns:1fr !important;}

/* Tooltip: bloco para fórmulas em notação matemática (MathJax) */
.tooltip .tt-math{
  margin:8px 0;
  padding:8px 10px;
  background:#f6f8fb;
  border:1px solid var(--line);
  border-radius:14px;
  overflow:auto;
}

/* ===== devs em grade 2x2 dentro do card ===== */
#rankBoard .teamDevs.devgrid{
  display:grid !important;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: 2px 10px;
  margin-top:2px;
  white-space:normal !important;
  overflow:visible !important;
  text-overflow:clip !important;
  font-size:12px !important;
  line-height:1.15 !important;
}
#rankBoard .teamDevs.devgrid .dev{
  display:block;
  font-family: ui-monospace;
}


/* ===== ranking sem scroll: vira grid e quebra linha ===== */
#rankBoard.rankBoard{
  display:grid !important;
  gap:10px !important;
  overflow:visible !important;      /* tira scroll */
  padding-bottom:0 !important;
}

/* Desktop: tenta 5 colunas */
@media(min-width:1200px){
  #rankBoard.rankBoard{ grid-template-columns: repeat(5, minmax(160px, 1fr)); }
}
/* Médio: 3 colunas (vai ficar 3+2) */
@media(min-width:820px) and (max-width:1199px){
  #rankBoard.rankBoard{ grid-template-columns: repeat(3, minmax(160px, 1fr)); }
}
/* Menor: 2 colunas */
@media(max-width:819px){
  #rankBoard.rankBoard{ grid-template-columns: repeat(2, minmax(160px, 1fr)); }
}

/* Importante: se você tinha isso, DESATIVE (flex fixo) */
#rankBoard .teamCol{ flex:unset !important; width:auto !important; }




/* ===== Ranking cards: 5 cards visíveis + devs 2x2 ===== */
#rankBoard.rankBoard{
  display:grid !important;
  grid-template-columns:repeat(5, minmax(0,1fr)) !important;
  gap:10px !important;
  overflow-x:visible !important;
  align-items:stretch !important;
}
#rankBoard .teamCol{
  flex:unset !important;
  width:auto !important;
  min-width:0 !important;
}
#rankBoard .teamName{ font-size:12px !important; }

#rankBoard .teamDevs{
  display:grid !important;
  grid-template-columns:1fr 1fr !important;
  gap:2px 6px !important;
  margin-bottom:8px !important;
  font-size:12px !important;
  line-height:1.15 !important;
  color:var(--muted) !important;
  white-space:normal !important;
  overflow:visible !important;
  text-overflow:clip !important;
}
#rankBoard .teamDevs .dev{
  display:block;
  font-family:var(--mono);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}


  </style>
</head>
<body>
<div id="tooltip" class="tooltip"></div>
<header>
  <div class="topbar">
  <h1>Dashboard BN — Team Fit (AT / AC / AE)</h1>

  <div class="row top-controls">
    <div>
      
      <select id="projectSel"></select>
    </div>
    <div>
      
      <select id="teamSel"></select>
    </div>
  </div>
</div>

  
    <!-- STRIP FIXO (Projeto) -->
  <div id="projectStrip" class="projectStrip" style="display:none">
    <div class="stripCard" style="flex:0.80">
      <div class="stripTitle">
        <span><b>Cobertura técnica</b> (M/S/C) + redundância</span>
        <span class="mini" id="covTeamLabel"></span>
      </div>
      <div id="covBars" class="covRows"></div>
    </div>

    <div class="stripCard" style="flex:2.6">
      <div class="stripTitle">
        <span><b>Ranking</b> por equipe (Expert × BN)</span>
        <span class="mini" id="rankMeta"></span>
      </div>
      <div id="rankBoard" class="rankBoard"></div>
    </div>



    <!-- NOVO: KPIs à direita -->
    <div class="stripCard kpiStrip" style="flex:0.75">
      <div class="stripTitle">
        <span><b>Resumo</b> (AE/AT/AC)</span>
        <span class="mini"></span>
      </div>

      <!-- COLE AQUI o seu antigo <div class="kpis"> ... </div> -->
      <div class="kpis">
          <div class="kpi">
            <div class="t">AE  </div>
            <div class="v" id="kpiAE">—</div>
            <div class="s" id="kpiAETier">—</div>
          
            <div class="t">AT </div>
            <div class="v" id="kpiAT">—</div>
            <div class="s" id="kpiATTier">—</div>
          
            <div class="t">AC  </div>
            <div class="v" id="kpiAC">—</div>
            <div class="s" id="kpiACTier">—</div>
          </div>
      </div>
    </div>
  </div>
<!-- MathJax (renderização LaTeX no tooltip) -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['\\(','\\)']], displayMath: [['\\[','\\]']] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

</header>

<div class="wrap">
  <div class="grid">
    <!-- LEFT -->
    <section class="card">
      <div class="hd">
        <strong>1) Dados (importar / atualizar)</strong>
        <div class="row">
          <label class="btn">
            <input id="fileInput" class="btn" type="file" accept=".csv,.tsv,.txt" />
            Importar arquivo
          </label>
          <button id="btnSample" class="btn">Carregar exemplo</button>
          <button id="btnClear" class="btn">Limpar</button>
          
        </div>
      </div>
      <div class="bd">
        <div id="msg" class="note" style="display:none"></div>
        <div id="detailsBox" class="detailsBox" style="display:none"></div>

        <div id="err" class="err" style="display:none"></div>

        

        <div style="height:10px"></div>

        

        
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card">
      <div class="hd">
        <strong>2) Rede (estrutura + pesos/funções)</strong>
        <div class="pill">AT: <span class="mono">WMAX</span> (Dom=1, Eco=1, Ling=3)</div>
        <div class="pill">AC: <span class="mono">WMAX</span> (PC_VL=1, PC_L=2, PC_M=5, PC_H=1, PC_VH=5)</div>
        <div class="pill">AE: <span class="mono">WMIN</span> (AT=3, AC=1)</div>
      </div>
      <div class="bd">
        <div class="split" style="grid-template-columns:1fr">
          <div class="barwrap">
            <div class="barcard">
              
              <div class="svgbox">
                <div id="bnGraphWrap">
                  <svg id="bnGraph"
                      width="1200" height="440"
                      viewBox="0 0 1850 280"
                      preserveAspectRatio="xMinYMin meet"
                      aria-label="Rede Bayesiana (com gráficos por nó)">
                  </svg>
                </div>
              <div style="height:12px"></div>

              <div class="barcard" style="margin-top:10px">
                <div class="ttl">
                  <strong>Radar por equipe (OSF / SLF / nº de projetos em comum)</strong>
                  <span class="mini" id="projMetaRadar"></span>
                </div>
                <div id="radarGrid" class="radarGrid"></div>
              </div>


              <div class="barcard">
                <div class="ttl">
                  <strong>Comparativo do projeto — distribuição por equipe (VL..VH)</strong>
                  
                </div>

                <div class="grid2" style="margin-top:10px">
                  <div class="barcard">
                    <div class="ttl"><strong>AT</strong><span class="mini" id="projMetaAT">AT (dist_AT)</span></div>
                    <svg id="projAT" width="100%" height="300" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                    <div class="ttl"><strong>AC</strong><span class="mini" id="projMetaAC">AC (dist_AC)</span></div>
                    <svg id="projAC" width="100%" height="300" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                    <div class="ttl"><strong>AE</strong><span class="mini" id="projMetaAE">AE (dist_AE)</span></div>
                    <svg id="projAE" width="100%" height="300" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                  <div class="ttl"><strong>Dom / Eco / Ling / PC</strong><span class="mini" id="projMetaTech">Dom/Eco/Ling/PC</span></div>

                  <!-- Painéis compactos (3 colunas) -->
                  <div class="grid2" style="margin-top:10px">
                    <div class="barcard">
                      <div class="ttl"><strong>Dom</strong><span class="mini">dist_Dom / Dom_tier</span></div>
                      <svg id="projDOM" width="100%" height="260" viewBox="0 0 520 260"></svg>
                    </div>
                    <div class="barcard">
                      <div class="ttl"><strong>Eco</strong><span class="mini">dist_Eco / Eco_tier</span></div>
                      <svg id="projECO" width="100%" height="260" viewBox="0 0 520 260"></svg>
                    </div>
                    <div class="barcard">
                      <div class="ttl"><strong>Ling</strong><span class="mini">dist_Ling / Ling_tier</span></div>
                      <svg id="projLING" width="100%" height="260" viewBox="0 0 520 260"></svg>
                    </div>

                    <!-- 4º painel: PC ocupa a linha inteira (pela regra do grid2) -->
                    <div class="barcard">
                      <div class="ttl"><strong>PC</strong><span class="mini">dist_PC</span></div>
                      <svg id="projPC" width="100%" height="260" viewBox="0 0 760 260"></svg>
                    </div>
                  </div>
                </div>

                </div>



                
                <div class="barcard">
                  <div class="ttl">
                    <strong>Tecnologias alvo </strong>
                    
                  </div>

                  <div id="techTargetsText" class="mini" style="margin:-6px 0 6px 0;color:#9fb0c0"></div>

                  <svg id="projTechOcc" width="100%" height="420" viewBox="0 0 760 420"></svg>
                </div>


              </div>

              </div>

              <!--<div class="legend">
                <div class="leg"><span class="sw" style="background:#7aa2ff"></span>Equipe selecionada</div>
                <div class="leg"><span class="sw" style="background:#62d26f"></span>Referência / centroides</div>
              </div>-->

              
              <div style="height:10px"></div>

              

            </div>
          </div>
        </div>

        <div style="height:12px"></div>

       

        

        <!--<div class="barcard">
          <div class="ttl">
            <strong>3) Tabela de evidências e resultado (linha do CSV)</strong>
            <span class="mini">mostra exatamente o que entrou/saíu</span>
          </div>
          <div style="overflow:auto">
            <table id="rowTable"></table>
          </div>
          <div class="foot">
            Dica: se você quiser incluir Dom/Eco/Ling discretizados (VL..VH) e PC_VL..PC_VH, basta adicionar colunas no CSV.
            O dashboard já está pronto para plugar esses valores nos rótulos do grafo (lado esquerdo).
          </div>
        </div>-->

      </div>
    </section>
  </div>
</div>

<script>
/* =======================
   Config (você pode editar)
   ======================= */
const CENTROIDS = [
  {tier:"VL", v:0.1}, {tier:"L", v:0.3}, {tier:"M", v:0.5}, {tier:"H", v:0.7}, {tier:"VH", v:0.9}
];

const DEFAULT_MODEL = {
  AT: { func: "WMAX", weights: { Dom: 1, Eco: 1, Ling: 3 } },
  AC: { func: "WMAX", weights: { PC_VL: 1, PC_L: 2, PC_M: 5, PC_H: 1, PC_VH: 5 } },
  AE: { func: "WMIN", weights: { AT: 3, AC: 1 } }
};

/* Tooltips (aparecem ao passar o mouse nos nós AT/AC/AE) */
const TOOLTIP_TEMPLATES = {
  TT_AT: () => ({
    title: "AT — Technological Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AT.func}`,
      `Pesos: Dom=${DEFAULT_MODEL.AT.weights.Dom}, Eco=${DEFAULT_MODEL.AT.weights.Eco}, Ling=${DEFAULT_MODEL.AT.weights.Ling}`,
      "Fórmula:",
      `\\[ S = \\sum_{j=1}^{n} x_j \\]`,
      `\\[ e_i = \\frac{w_i x_i + \\sum_{j \\ne i} x_j}{w_i + (n-1)} \\]`,
      `\\[ \\mathrm{WMAX}(x,w) = \\max_i e_i \\]`
    ],
    note: "Aqui, x_i é o score (0–1) de Dom/Eco/Ling. Se x_i vier como vetor (amostras), o max é posição a posição."
  }),
  TT_AC: () => ({
    title: "AC — Collaboration Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AC.func}`,
      `Pesos: PC_VL=${DEFAULT_MODEL.AC.weights.PC_VL}, PC_L=${DEFAULT_MODEL.AC.weights.PC_L}, PC_M=${DEFAULT_MODEL.AC.weights.PC_M}, PC_H=${DEFAULT_MODEL.AC.weights.PC_H}, PC_VH=${DEFAULT_MODEL.AC.weights.PC_VH}`,
      "Fórmula:",
      `\\[ S = \\sum_{j=1}^{n} x_j \\]`,
      `\\[ e_i = \\frac{w_i x_i + \\sum_{j \\ne i} x_j}{w_i + (n-1)} \\]`,
      `\\[ \\mathrm{WMAX}(x,w) = \\max_i e_i \\]`

    ],
    note: "Aqui, x_i vem da evidência de colaboração (ex.: PC_VL..PC_VH, ou depois sua transformação para valor 0–1)."
  }),
  TT_AE: () => ({
    title: "AE — Team Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AE.func}`,
      `Pesos: AT=${DEFAULT_MODEL.AE.weights.AT}, AC=${DEFAULT_MODEL.AE.weights.AC}`,
      "Fórmula:",
       `\\[ S = \\sum_{j=1}^{n} x_j \\]`,
      `\\[ e_i = \\frac{w_i\\,x_i + (S - x_i)}{w_i + (n - 1)} \\]`,
      `\\[ \\mathrm{WMIN}(x,w) = \\min_i e_i \\]`
    ],
    note: "Aqui, x_i são os valores contínuos de AT e AC (0–1)."
  })
};

function tooltipHtml(t){
  const esc = (s)=>String(s)
    .replaceAll("&","&amp;").replaceAll("<","&lt;")
    .replaceAll(">","&gt;").replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
  const lines = (t.lines||[]).map(l=>{
    // Fórmulas em LaTeX (MathJax): use \( ... \) ou \[ ... \]
    const isMath = (typeof l === "string") && (l.startsWith("\\(") || l.startsWith("\\["));
    if (isMath){
      return `<div class="tt-math">${l}</div>`;
    }
    // linhas de pesos/detalhes em monoespaçado
    if (l.includes("=") || l.includes("WMAX") || l.includes("WMIN") || l.includes("e_i")){
      return `<div class="tt-mono">${esc(l)}</div>`;
    }
    return `<div>${esc(l)}</div>`;
  }).join("");

  return `<div class="tt-title">${esc(t.title||"")}</div>${lines}${t.note?`<div class="tt-muted">${esc(t.note)}</div>`:""}`;
}


function attachNodeTooltips(){
  const tip = $("tooltip");
  if (!tip) return;

  function bind(el){
    el.addEventListener("mouseenter", ()=>{
      const id = el.getAttribute("data-tooltip-id");
      const builder = TOOLTIP_TEMPLATES[id];
      if (!builder) return;
      tip.innerHTML = tooltipHtml(builder());
      // renderiza LaTeX no tooltip (se MathJax estiver carregado)
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([tip]);

      tip.style.display = "block";
    });
    el.addEventListener("mousemove", (ev)=>{
      const pad = 14;
      const w = tip.offsetWidth || 380;
      const h = tip.offsetHeight || 120;
      let x = ev.clientX + pad;
      let y = ev.clientY + pad;
      const maxX = window.innerWidth - w - 8;
      const maxY = window.innerHeight - h - 8;
      x = Math.min(x, maxX);
      y = Math.min(y, maxY);
      tip.style.left = x + "px";
      tip.style.top = y + "px";
    });
    el.addEventListener("mouseleave", ()=>{
      tip.style.display = "none";
    });
  }

  const els = document.querySelectorAll("[data-tooltip-id]");
  els.forEach(bind);
}



// Paleta simples (para quando você quiser comparar várias equipes no mesmo gráfico)
const COLORS = ["#7aa2ff", "#62d26f", "#ffd166", "#ff6b6b", "#c77dff", "#4dd4ff"];

/* =======================
   Util
   ======================= */
function $(id){ return document.getElementById(id); }

function setText(id, value){
  const el = $(id);
  if (!el) return;
  el.textContent = value;
}
function setHTML(id, html){
  const el = $(id);
  if (!el) return;
  el.innerHTML = html;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmt(x, d=3){
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  const n = Number(x);
  if (!Number.isFinite(n)) return String(x);
  return n.toFixed(d);
}
function nearestTier(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return {tier:"—", centroid:null, dist:null};
  let best = null;
  for (const c of CENTROIDS){
    const dist = Math.abs(n - c.v);
    if (!best || dist < best.dist) best = {tier:c.tier, centroid:c.v, dist};
  }
  return best;
}
function oneHotDistFromTier(tier){
  const order = ["VL","L","M","H","VH"];
  const idx = order.indexOf(tier);
  if (idx < 0) return [0.2,0.2,0.2,0.2,0.2];
  const out = [0,0,0,0,0];
  out[idx] = 1;
  return out;
}
function scalarTo5StateDist(v){
  const t = nearestTier(v);
  return oneHotDistFromTier(t.tier);
}

function safeParseFloat(s){
  if (s === null || s === undefined) return NaN;
  if (typeof s === "number") return s;
  const t = String(s).trim().replace(",", "."); // aceita decimal com vírgula
  const n = Number(t);
  return Number.isFinite(n) ? n : NaN;
}

/* =======================
   CSV/TSV parsing (robusto p/ TAB e aspas)
   ======================= */
function detectDelimiter(headerLine){
  const tabs  = (headerLine.match(/\t/g) || []).length;
  const commas = (headerLine.match(/,/g) || []).length;
  const semis  = (headerLine.match(/;/g) || []).length;

  // prioridade: o que tiver mais separadores no cabeçalho
  if (tabs >= commas && tabs >= semis) return "\t";
  if (semis > commas) return ";";
  return ",";
}


function splitLine(line, delim){
  // split respeitando aspas
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0; i<line.length; i++){
    const ch = line[i];
    if (ch === '"'){
      // dupla aspas -> escape
      if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    } else if (ch === delim && !inQ){
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map(s => s.trim());
}
function joinQuotedLines(text){
  const raw = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

  const lines = [];
  let cur = "";
  let inQ = false;

  function countQuoteToggles(line){
    let toggles = 0;
    for (let i=0; i<line.length; i++){
      if (line[i] === '"'){
        // aspas escapada ("")
        if (i+1 < line.length && line[i+1] === '"'){ i++; continue; }
        toggles++;
      }
    }
    return toggles;
  }

  for (const line of raw){
    cur = cur ? (cur + "\n" + line) : line;

    if (countQuoteToggles(line) % 2 === 1){
      inQ = !inQ;
    }

    if (!inQ){
      if (cur.trim().length > 0) lines.push(cur);
      cur = "";
    }
  }

  if (cur.trim().length > 0) lines.push(cur);
  return lines;
}


function parseTextToRows(text){
  // normaliza quebras
  const lines = joinQuotedLines(text);
  if (!lines.length) return {cols:[], rows:[]};

  const delim = detectDelimiter(lines[0]);
  const cols = splitLine(lines[0], delim);

  const rows = [];
  for (let i=1; i<lines.length; i++){
    const parts = splitLine(lines[i], delim);

    // caso: CSV com dist_AE quebrado em várias colunas
    // esperadas 8 colunas; se tiver > 8, junta o resto em dist_AE
    if (parts.length > cols.length){
      const fixed = parts.slice(0, cols.length-1);
      const tail = parts.slice(cols.length-1).join(delim); // junta de volta
      parts.length = 0;
      parts.push(...fixed, tail);
    }

    const obj = {};
    for (let c=0; c<cols.length; c++){
      obj[cols[c]] = (parts[c] ?? "").trim();
    }
    rows.push(obj);
  }
  return {cols, rows};
}

function parseDistAE(v){
  // aceita "0.1,0.2,0.3,0.4,0.0" ou "[...]" etc.
  const raw = String(v ?? "").trim().replace(/^\[|\]$/g,"");
  const parts = raw.split(",").map(s => safeParseFloat(s.trim())).filter(n => Number.isFinite(n));
  // se vier mais que 5 (ex.: por erro), corta; se vier menos, completa
  const arr = parts.slice(0,5);
  while (arr.length < 5) arr.push(0);
  // normaliza se soma não for 1 (só p/ visual)
  const sum = arr.reduce((a,b)=>a+b,0);
  if (sum > 0.000001){
    return arr.map(x => x/sum);
  }
  return arr;
}

/* =======================
   Estado do app
   ======================= */
let DATA = [];        // linhas
let COLUMNS = [];     // colunas
let IDX = {projects:[], teamsByProject:new Map()};

function setMessage(kind, text){
  const msg = $("msg");
  const err = $("err");
  msg.style.display = "none"; err.style.display = "none";
  if (!text) return;
  if (kind === "err"){ err.textContent = text; err.style.display="block"; }
  else { msg.textContent = text; msg.style.display="block"; }
}

function buildIndex(){
  const projects = Array.from(new Set(DATA.map(r => r.projeto_id || r.project_id || r.project || "—"))).sort();
  const teamsByProject = new Map();
  for (const p of projects){
    const teams = DATA.filter(r => (r.projeto_id||r.project_id||r.project||"—") === p)
                      .map(r => r.team_id || r.team || r.teamId || "—");
    teamsByProject.set(p, Array.from(new Set(teams)).sort());
  }
  IDX = {projects, teamsByProject};
}

function pickFirst(){
  const p = IDX.projects[0] ?? "";
  const t = (IDX.teamsByProject.get(p) || [])[0] ?? "";
  return {p, t};
}

/* =======================
   Render helpers (SVG)
   ======================= */
function svgClear(svg){
  if (!svg) return;
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
function syncViewBox(svg, fallbackW=760, fallbackH=260){
  if(!svg) return {W:fallbackW,H:fallbackH};
  const r = (typeof svg.getBoundingClientRect === "function") ? svg.getBoundingClientRect() : null;
  const w = r && r.width ? Math.round(r.width) : 0;
  const h = r && r.height ? Math.round(r.height) : 0;
  const W = (w >= 10) ? Math.max(320, w) : fallbackW;
  const H = (h >= 10) ? Math.max(200, h) : fallbackH;
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  // evita “meet” (que reduz e cria área vazia quando o SVG está em 3 colunas)
  svg.setAttribute("preserveAspectRatio","none");
  return {W,H};
}

function svgEl(name, attrs={}){
  const el = document.createElementNS("http://www.w3.org/2000/svg", name);
  for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function drawBars(svg, probs, color="#7aa2ff"){
  if(!svg) return;
  svgClear(svg);
  const W = 520, H = 160;
  const padL=50, padR=20, padT=16, padB=30;
  const innerW = W-padL-padR, innerH = H-padT-padB;

  // axes
  svg.appendChild(svgEl("line",{x1:padL,y1:padT+innerH,x2:padL+innerW,y2:padT+innerH,stroke:"#2a3b55","stroke-width":"2"}));
  svg.appendChild(svgEl("line",{x1:padL,y1:padT,x2:padL,y2:padT+innerH,stroke:"#2a3b55","stroke-width":"2"}));

  const labels = ["VL","L","M","H","VH"];
  const max = Math.max(...probs, 0.01);
  const bw = innerW/labels.length * 0.65;
  const gap = innerW/labels.length;

  for (let i=0;i<labels.length;i++){
    const x = padL + i*gap + (gap-bw)/2;
    const h = (probs[i]/max) * innerH;
    const y = padT + innerH - h;

    svg.appendChild(svgEl("rect",{x:x,y:y,width:bw,height:h,rx:"8",ry:"8",fill:color,opacity:"0.85"}));

    // value label
    const txt = svgEl("text",{x:x+bw/2,y:y-6,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = (probs[i]*100).toFixed(1)+"%";
    svg.appendChild(txt);

    // tier label
    const lab = svgEl("text",{x:x+bw/2,y:padT+innerH+20,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = labels[i];
    svg.appendChild(lab);
  }

  // y ticks (0 e 100% do max)
  const t0 = svgEl("text",{x:padL-10,y:padT+innerH+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  t0.textContent = "0";
  svg.appendChild(t0);
  const t1 = svgEl("text",{x:padL-10,y:padT+10,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  t1.textContent = (max*100).toFixed(0)+"%";
  svg.appendChild(t1);
}


function distFromTier(tier){
  const map = {VL:0, L:1, M:2, H:3, VH:4, "Very Low":0, "Low":1, "Medium":2, "High":3, "Very High":4};
  const k = map[String(tier||"").trim()] ;
  const a = [0,0,0,0,0];
  if (k === 0 || k === 1 || k === 2 || k === 3 || k === 4) a[k] = 1;
  return a;
}
function distFromTierScore(tier, score){
  const map = {VL:0, L:1, M:2, H:3, VH:4, "Very Low":0, "Low":1, "Medium":2, "High":3, "Very High":4};
  const k = map[String(tier||"").trim()];
  const a = [0,0,0,0,0];

  const s = Number.isFinite(score) ? Math.max(0, Math.min(1, score)) : 1; // clamp 0..1
  if (k === 0 || k === 1 || k === 2 || k === 3 || k === 4) a[k] = s;

  return a;
}

function distFromCont(x){
  // aproxima distribuição pelo valor contínuo: quanto mais perto do centroide, maior o peso
  const n = safeParseFloat(x);
  if (!Number.isFinite(n)) return [0,0,0,0,0];
  const raw = CENTROIDS.map(c => Math.max(0, 1 - (Math.abs(n - c.v) / 0.40))); // 0.40 = largura simples
  const sum = raw.reduce((a,b)=>a+b,0);
  if (sum < 1e-9) return distFromTier(nearestTier(n).tier);
  return raw.map(v => v/sum);
}

function drawMiniBars(svg, probs, color="#7aa2ff"){
  svgClear(svg);
  const W = 520, H = 120;
  const padL=10, padR=10, padT=10, padB=26;
  const innerW = W-padL-padR, innerH = H-padT-padB;

  const labels = ["VL","L","M","H","VH"];
  const max = Math.max(...probs, 0.01);
  const bw = innerW/labels.length * 0.68;
  const gap = innerW/labels.length;

  for (let i=0;i<labels.length;i++){
    const x = padL + i*gap + (gap-bw)/2;
    const h = (probs[i]/max) * innerH;
    const y = padT + innerH - h;

    svg.appendChild(svgEl("rect",{x:x,y:y,width:bw,height:h,rx:"8",ry:"8",fill:color,opacity:"0.85"}));

    const txt = svgEl("text",{x:x+bw/2,y:y-6,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = (probs[i]*100).toFixed(1)+"%";
    svg.appendChild(txt);

    const lab = svgEl("text",{x:x+bw/2,y:padT+innerH+18,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = labels[i];
    svg.appendChild(lab);
  }
}


function drawNodeWithBars(svg, {x,y,w,h,title,dist, funcLabel=null, weightsLabel="", metaLabel="", tooltipId=null, barLabels=null, barWidthRatio=0.68, maxValue=null}){

  const g = svgEl("g",{});
  g.appendChild(svgEl("rect",{x,y,width:w,height:h,rx:"18",ry:"18",fill:"#ffffff",stroke:"#d7dde6"}));

  const t = svgEl("text",{x:x+w/2,y:y+26,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-weight":"800","font-family":"ui-sans-serif"});
  t.textContent = title;
  g.appendChild(t);

  if (metaLabel){
    const meta = svgEl("text",{x:x+w-12,y:y+26,"text-anchor":"end",fill:"#6b7280","font-size":"20","font-family":"ui-monospace"});
    meta.textContent = metaLabel;
    g.appendChild(meta);
  }

  if (funcLabel){
    const fx = x + 14;
    const fy = y + 48;
    const f = svgEl("text",{x:fx,y:fy,fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    f.textContent = funcLabel;
    if (tooltipId){
      f.setAttribute("data-tooltip-id", tooltipId);
      f.setAttribute("class", "formulaTag");
    }
    g.appendChild(f);

    const wtxt = svgEl("text",{x:fx + 80,y:fy,fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    wtxt.textContent = weightsLabel || "";
    g.appendChild(wtxt);
  }

  const pad = 14;
  const barTop = y + 60;
  const barH = h - 60 - 28;
  const barY0 = barTop + barH;
  const labels = barLabels || ["VL","L","M","H","VH"];

    // ====== BARRAS HORIZONTAIS (substitui as colunas verticais) ======
  const max = (Number.isFinite(maxValue) && maxValue > 0)
    ? maxValue
    : Math.max(...dist, 0.001);

  // espaço para o rótulo (VL..VH) na esquerda e % na direita
  const labelCol = Math.min(110, Math.max(...labels.map(s => String(s).length)) * 7 + 18);
  const pctCol   = 46; // espaço para "100%"
  const barX0    = x + pad + labelCol;
  const barWmax  = Math.max(10, w - (barX0 - x) - pad - pctCol);

  const rowGap = barH / labels.length;
  const bh = Math.max(10, rowGap * 0.60);

  for (let i=0;i<labels.length;i++){
    const by = barTop + i*rowGap + (rowGap - bh)/2;
    const bw = (dist[i]/max) * barWmax;

    // rótulo (VL..VH) à esquerda
    const l = svgEl("text",{
      x: barX0 - 8,
      y: by + bh*0.72,
      "text-anchor":"end",
      fill:"#4b5563",
      "font-size":"20",
      "font-family":"ui-monospace"
    });
    l.textContent = labels[i];
    g.appendChild(l);

    // barra horizontal
    g.appendChild(svgEl("rect",{
      x: barX0,
      y: by,
      width: bw,
      height: bh,
      rx:"8", ry:"8",
      fill:"#8fb0ff",
      opacity:"0.95"
    }));

    // percentual à direita da barra
    const p = svgEl("text",{
      x: barX0 + bw + 8,
      y: by + bh*0.72,
      "text-anchor":"start",
      fill:"#0b1220",
      "font-size":"20",
      "font-family":"ui-monospace"
    });
    p.textContent = (dist[i]*100).toFixed(0) + "%";
    g.appendChild(p);
  }


  svg.appendChild(g);
  return {x,y,w,h};
}


function drawArrow(svg, x1,y1,x2,y2){
  svg.appendChild(svgEl("line",{
    x1,y1,x2,y2,
    stroke:"#6b7280",
    "stroke-width":"2.2",
    "marker-end":"url(#arrow)"
  }));
}


function renderBNGraph(row, dists){
  const svg = $("bnGraph");
  if (!svg) return;
  svgClear(svg);

  const defs = svgEl("defs",{});
  const marker = svgEl("marker",{id:"arrow",viewBox:"0 0 10 10",refX:"9",refY:"5",markerWidth:"8",markerHeight:"8",orient:"auto-start-reverse"});
  marker.appendChild(svgEl("path",{d:"M 0 0 L 10 5 L 0 10 z", fill:"#6b7280"}));
  defs.appendChild(marker);
  svg.appendChild(defs);


  //mudar tamanho das caixas dos graficos
  const smallW = 380, smallH = 50;
  const boxW = 500, boxH = 240;
  const boxW_AT = 600
  const TIER = ["VL","L","M","H","VH"];


  function compactNonZero(dist){
    const pairs = TIER.map((lab,i)=>({lab, v:Number(dist?.[i] ?? 0)}))
                    .filter(p => p.v > 1e-9);
    return pairs.length
      ? { dist: pairs.map(p=>p.v), labels: pairs.map(p=>p.lab) }
      : { dist: [0], labels: ["—"] };
  }

  const domC  = compactNonZero(dists.dom);
  const ecoC  = compactNonZero(dists.eco);
  const lingC = compactNonZero(dists.ling);

  // e agora desenhe assim:
  const dom = drawNodeWithBars(svg,{
    x:50,y:0,w:smallW,h:smallH,title:"Domínio",
    dist: domC.dist, barLabels: domC.labels, maxValue: 1,
    metaLabel: dists.metaDom
  });
  const eco = drawNodeWithBars(svg,{
    x:50,y:60,w:smallW,h:smallH,title:"Ecossistema",
    dist: ecoC.dist, barLabels: ecoC.labels, maxValue: 1,
    metaLabel: dists.metaEco
  });
  const ling= drawNodeWithBars(svg,{
    x:50,y:120,w:smallW,h:smallH,title:"Linguagens ",
    dist: lingC.dist, barLabels: lingC.labels, maxValue: 1,
    metaLabel: dists.metaLing
  });

  //const dom = drawNodeWithBars(svg,{x:50,y:40,w:smallW,h:smallH,title:"Domínio (Dom)",dist:dists.dom, metaLabel:dists.metaDom});
  //const eco = drawNodeWithBars(svg,{x:50,y:190,w:smallW,h:smallH,title:"Ecossistema (Eco)",dist:dists.eco, metaLabel:dists.metaEco});
  //const ling= drawNodeWithBars(svg,{x:50,y:340,w:smallW,h:smallH,title:"Linguagens (Ling)",dist:dists.ling, metaLabel:dists.metaLing});
  // PC evidence as five nodes: PC_VL..PC_VH (each mapped to VL..VH states)
  
  const pcTitles = ["PC_VL","PC_L","PC_M","PC_H","PC_VH"];
  const shares = (dists.pc || [0,0,0,0,0]).map(x=>Number(x));
  const pcNodes = [];

  const pcX = dom.x;                 // alinha na mesma coluna de Dom/Eco/Ling
  const pcY0 = ling.y + ling.h + 26; // começa logo abaixo de Linguagens
  const pcW = dom.w;                 // mesma largura das caixas da esquerda
  const pcH = 50, pcGap = 10;


  for (let i=0;i<5;i++){
    const s = Number.isFinite(shares[i]) ? shares[i] : 0;
    pcNodes.push(drawNodeWithBars(svg,{
      x: pcX,
      y: pcY0 + i*(pcH+pcGap),
      w: pcW,
      h: pcH,
      title: pcTitles[i],
      dist: [Math.max(0, Math.min(1, s))],
      barLabels: [""],//["% pares"],
      maxValue: 1,     // distribuição VL..VH do PC_*
      metaLabel: (s*100).toFixed(0)+"%" // mostra o share como “46%”
    }));
  }

 
  


  const at  = drawNodeWithBars(svg,{x:650,y:0,w:boxW,h:boxH,title:"AT (Aptidão Tecnológica)",dist:dists.at,
    funcLabel: DEFAULT_MODEL.AT.func,
    weightsLabel:`(Dom=${DEFAULT_MODEL.AT.weights.Dom}, Eco=${DEFAULT_MODEL.AT.weights.Eco}, Ling=${DEFAULT_MODEL.AT.weights.Ling})`,
    tooltipId: "TT_AT"// DEFAULT_MODEL.AT.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  const ac  = drawNodeWithBars(svg,{x:650,y:240,w:boxW,h:boxH,title:"AC (Aptidão Colaborativa)",dist:dists.ac,
    funcLabel: DEFAULT_MODEL.AC.func,
    weightsLabel:`(PC_VL=${DEFAULT_MODEL.AC.weights.PC_VL}, PC_L=${DEFAULT_MODEL.AC.weights.PC_L}, PC_M=${DEFAULT_MODEL.AC.weights.PC_M}, PC_H=${DEFAULT_MODEL.AC.weights.PC_H}, PC_VH=${DEFAULT_MODEL.AC.weights.PC_VH})`,
    tooltipId: "TT_AC" //DEFAULT_MODEL.AC.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  const ae  = drawNodeWithBars(svg,{x:1280,y:125,w:boxW,h:boxH,title:"AE (Aptidão da Equipe)",dist:dists.ae,
    funcLabel: DEFAULT_MODEL.AE.func,
    weightsLabel:`(AT=${DEFAULT_MODEL.AE.weights.AT}, AC=${DEFAULT_MODEL.AE.weights.AC})`,
    tooltipId:"TT_AE" // DEFAULT_MODEL.AE.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  drawArrow(svg, dom.x+dom.w, dom.y+dom.h/2, at.x, at.y+50);
  drawArrow(svg, eco.x+eco.w, eco.y+eco.h/2, at.x, at.y+boxH/2);
  drawArrow(svg, ling.x+ling.w, ling.y+ling.h/2, at.x, at.y+boxH-50);

  const acY0 = ac.y + 50;
  const acYstep = (boxH - 100) / 4;

  pcNodes.forEach((n, i) => {
    drawArrow(svg, n.x + n.w, n.y + n.h/2, ac.x, acY0 + i * acYstep);
  });


  drawArrow(svg, at.x+at.w, at.y+boxH/2, ae.x, ae.y+boxH/2 - 24);
  drawArrow(svg, ac.x+ac.w, ac.y+boxH/2, ae.x, ae.y+boxH/2 + 24);

  // re-bind tooltips for new SVG text nodes
  attachNodeTooltips();
}
function renderTierOnly(el, title, tier, score){
  const s = Number(score);
  const sc = Number.isFinite(s) ? Math.max(0, Math.min(1, s)) : 0;
  const pct = Math.round(sc * 100);

  el.innerHTML = `
    <div class="mini">${title}</div>
    <div class="tierRow">
      <span class="tierTag mono">${tier || "-"}</span>

      <div class="tierTrack" title="${pct}% (${sc.toFixed(3)})">
        <div class="tierFill" style="width:${pct}%"></div>
      </div>

      <span class="tierPct mono">${pct}%</span>
    </div>
  `;
}


function drawAxis(svg, atVal, acVal, color="#7aa2ff"){
  if(!svg) return;
  svgClear(svg);
  const W=520, H=140;
  const padL=50,padR=20,padT=22,padB=28;
  const innerW=W-padL-padR, innerH=H-padT-padB;

  // baseline
  const yAT = padT + innerH*0.35;
  const yAC = padT + innerH*0.75;

  const baseStyle = {stroke:"#2a3b55","stroke-width":"8","stroke-linecap":"round"};
  svg.appendChild(svgEl("line",{x1:padL,y1:yAT,x2:padL+innerW,y2:yAT,...baseStyle}));
  svg.appendChild(svgEl("line",{x1:padL,y1:yAC,x2:padL+innerW,y2:yAC,...baseStyle}));

  // centroid marks
  for (const c of CENTROIDS){
    const x = padL + c.v * innerW;
    for (const y of [yAT,yAC]){
      svg.appendChild(svgEl("line",{x1:x,y1:y-10,x2:x,y2:y+10,stroke:"#62d26f","stroke-width":"2",opacity:"0.9"}));
    }
    const lab = svgEl("text",{x:x,y:padT+innerH+20,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = c.tier;
    svg.appendChild(lab);
  }

  function drawPoint(val, y, label){
    const v = clamp(Number(val), 0, 1);
    const x = padL + v*innerW;

    // glow
    svg.appendChild(svgEl("circle",{cx:x,cy:y,r:"10",fill:color,opacity:"0.22"}));
    svg.appendChild(svgEl("circle",{cx:x,cy:y,r:"6",fill:color,opacity:"0.92"}));

    const t = nearestTier(v);
    const txt = svgEl("text",{x:x,y:y-14,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = `${label}: ${fmt(v,3)} (${t.tier})`;
    svg.appendChild(txt);
  }

  // labels
  const l1 = svgEl("text",{x:padL-12,y:yAT+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  l1.textContent="AT";
  svg.appendChild(l1);

  const l2 = svgEl("text",{x:padL-12,y:yAC+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  l2.textContent="AC";
  svg.appendChild(l2);

  drawPoint(atVal, yAT, "AT");
  drawPoint(acVal, yAC, "AC");
}

/* =======================
   UI: selects + render
   ======================= */
function fillSelect(sel, values){
  sel.innerHTML = "";
  for (const v of values){
    const opt = document.createElement("option");
    opt.value = v; opt.textContent = v;
    sel.appendChild(opt);
  }
}

function currentRow(){
  const p = $("projectSel").value;
  const t = $("teamSel").value;
  // pega a primeira linha que bate (se você tiver várias avaliações por equipe, pode mudar aqui)
  return DATA.find(r => (r.projeto_id||r.project_id||r.project||"—") === p &&
                        (r.team_id||r.team||r.teamId||"—") === t) || null;
}

function renderRowTable(row){
  const table = $("rowTable");
  if (!table) return; // PATCH: evita crash quando a tabela está removida/comentada

  if (!row){
    table.innerHTML = "<tr><td style='color:#9fb0c0'>— sem dados —</td></tr>";
    return;
  }
  const cols = COLUMNS.length ? COLUMNS : Object.keys(row);
  let html = "<thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>";
  for (const c of cols){
    const v = row[c] ?? "";
    const vv = (String(v).length>0) ? String(v) : "—";
    html += `<tr><td><code>${escapeHtml(c)}</code></td><td>${escapeHtml(vv)}</td></tr>`;
  }
  html += "</tbody>";
  table.innerHTML = html;
}


function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function safeInt(x){
  const n = parseInt(String(x ?? "").trim(), 10);
  return Number.isFinite(n) ? n : 0;
}
function normalizeList(v){
  const s = String(v ?? "").trim();
  if (!s) return [];
  return s.split(",").map(x=>x.trim()).filter(Boolean);
}
function uniq(arr){ return Array.from(new Set(arr)); }

function teamKey(row){
  return row.team_id ?? row.team ?? row.teamId ?? "—";
}
function shortDevs(teamStr){
  const s = String(teamStr ?? "").replace(/[\[\]]/g,"").trim();
  if (!s) return "";
  const parts = s.split(/[;,\s]+/).map(x=>x.trim()).filter(Boolean);
  if (!parts.length) return "";
  const shown = parts.slice(0,4).join(" · ");
  return parts.length>3 ? `${shown} · …` : shown;
}
function normalizeDevs(teamStr){
  const s = String(teamStr ?? "").replace(/[\[\]]/g,"").trim();
  if (!s) return [];
  return s.split(/[;,\n]+/).map(x=>x.trim()).filter(Boolean);
}
function devTitleStr(teamStr){
  const parts = normalizeDevs(teamStr).slice(0,4);
  return parts.join(" · ");
}
function devCellsHtml(teamStr){
  const parts = normalizeDevs(teamStr).slice(0,4);
  while (parts.length < 4) parts.push("—"); // mantém o grid 2x2 alinhado
  return parts.map(d=>`<span class="dev" title="${escapeHtml(d)}">${escapeHtml(d)}</span>`).join("");
}



function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

function devsGridHtml(teamStr){
  const s = String(teamStr ?? "").replace(/[\[\]]/g,"").trim();
  if (!s) return "";
  const parts = s.split(/[;,\s]+/).map(x=>x.trim()).filter(Boolean).slice(0,4);
  return parts.map(d => `<span class="dev">${escapeHtml(d)}</span>`).join("");
}

function renderCoveragePanel(row, label=""){
  const wrap = $("covBars");
  const lbl  = $("covTeamLabel");
  if (!wrap || !lbl) return;

  if (!row){
    wrap.innerHTML = "";
    lbl.textContent = "";
    return;
  }

  lbl.textContent = label ? `Equipe: ${label}` : "";

  const dims = [
    {k:"dominio",     label:"DOM"},
    {k:"ecossistema", label:"ECO"},
    {k:"linguagens",  label:"LING"}
  ];

  function covLine(prefix, kind){
    const total   = safeInt(row[`${prefix}_${kind}_total`]);
    const covered = safeInt(row[`${prefix}_${kind}_covered`]);
    const pct     = total>0 ? Math.round((covered/total)*100) : 0;
    return {total, covered, pct};
  }

  function topAndRedund(prefix){
    const all = uniq([
      ...normalizeList(row[`${prefix}_m_covered_list`]),
      ...normalizeList(row[`${prefix}_s_covered_list`]),
      ...normalizeList(row[`${prefix}_c_covered_list`]),
    ]);

    const redund = uniq([
      ...normalizeList(row[`${prefix}_m_covered_list`]).slice(safeInt(row[`${prefix}_m_total`])),
      ...normalizeList(row[`${prefix}_s_covered_list`]).slice(safeInt(row[`${prefix}_s_total`])),
      ...normalizeList(row[`${prefix}_c_covered_list`]).slice(safeInt(row[`${prefix}_c_total`])),
    ]);

    return {
      top: all.slice(0,2),
      redund: redund.slice(0,2),
      extraTop: Math.max(0, all.length-2),
      extraRed: Math.max(0, redund.length-2)
    };
  }

  function line(kind, obj){
    return `
      <div class="hbarLine" data-kind="${kind}">
        <div class="mini">${kind}</div>
        <div class="hbar"><span style="width:${obj.pct}%"></span></div>
        <div class="hbarMeta">${obj.total>0 ? `${obj.covered}/${obj.total}` : "—"}</div>
      </div>
    `;
  }

  wrap.innerHTML = dims.map(d=>{
    const M = covLine(d.k,"m");
    const S = covLine(d.k,"s");
    const C = covLine(d.k,"c");
    const t = topAndRedund(d.k);

    const topTxt = t.top.length ? `${t.top.join(", ")}${t.extraTop?` (+${t.extraTop})`:""}` : "—";
    const redTxt = t.redund.length ? `${t.redund.join(", ")}${t.extraRed?` (+${t.extraRed})`:""}` : "—";

    return `
      <div class="covRow">
        <div class="dim">${d.label}</div>
        <div class="covStack">
          ${line("M", M)}
          ${line("S", S)}
          ${line("C", C)}
          <div class="techHint"><b>Coberto:</b> ${escapeHtml(topTxt)} &nbsp; • &nbsp; <b>Redund.:</b> ${escapeHtml(redTxt)}</div>
        </div>
      </div>
    `;
  }).join("");
}

function renderProjectRankBoard(projectId, selectedRow){
  const strip = $("projectStrip");
  const board = $("rankBoard");
  const meta  = $("rankMeta");
  if (!strip || !board || !meta) return;

  if (!DATA || !DATA.length || !projectId){
    strip.style.display = "none";
    return;
  }

  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||r.project||"")===String(projectId));
  if (!rows.length){
    strip.style.display = "none";
    return;
  }

  const selTeam = selectedRow ? teamKey(selectedRow) : "";

  const maxRank = Math.max(
    ...rows.map(r=>safeParseFloat(r.rank_expert)).filter(Number.isFinite),
    ...rows.map(r=>safeParseFloat(r.rank_bn)).filter(Number.isFinite),
    rows.length
  ) || rows.length || 5;

  const ordered = rows.slice().sort((a,b)=>{
    const ra = safeParseFloat(a.rank_bn), rb = safeParseFloat(b.rank_bn);
    if (Number.isFinite(ra) && Number.isFinite(rb)) return ra-rb;

    const ea = safeParseFloat(a.rank_expert), eb = safeParseFloat(b.rank_expert);
    if (Number.isFinite(ea) && Number.isFinite(eb)) return ea-eb;

    return teamKey(a).localeCompare(teamKey(b));
  });

  meta.textContent = `${rows.length} equipes`;

  board.innerHTML = ordered.map(r=>{
    const t = teamKey(r);
    const devTitle = devTitleStr(r.team_str);
    const devCells = devCellsHtml(r.team_str);

    const re = safeParseFloat(r.rank_expert);
    const rb = safeParseFloat(r.rank_bn);

    const he = Number.isFinite(re) ? Math.round(((maxRank - re + 1)/maxRank)*100) : 0;
    const hb = Number.isFinite(rb) ? Math.round(((maxRank - rb + 1)/maxRank)*100) : 0;

    const active = (t===selTeam) ? "active" : "";

    return `
      <div class="teamCol ${active}" data-team="${escapeHtml(t)}">
        <div class="teamName" title="${escapeHtml(t)}">${escapeHtml(t)}</div>
        
        <div class="teamDevs" title="${escapeHtml(devTitle || "—")}">${devCells}</div>

        <div class="vbars">
          <div class="vbarBox" title="Ranking do expert (1 = melhor)">
            <div class="vbar expert" style="height:${he}%"></div>
            <div class="vnum">${escapeHtml(Number.isFinite(re) ? String(re) : "—")}</div>
          </div>
          <div class="vbarBox" title="Ranking da BN (1 = melhor)">
            <div class="vbar" style="height:${hb}%"></div>
            <div class="vnum">${escapeHtml(Number.isFinite(rb) ? String(rb) : "—")}</div>
          </div>
        </div>

        <div class="vlab"><span>EXPERT</span><span>BN</span></div>
      </div>
    `;
  }).join("");

  // Hover mostra a cobertura dessa equipe (sem perder o filtro)
  // Click seleciona a equipe no select e atualiza o dashboard inteiro
  const cols = board.querySelectorAll(".teamCol");
  cols.forEach(col=>{
    const teamId = col.getAttribute("data-team");
    const r = ordered.find(x=>String(teamKey(x))===String(teamId));
    if (!r) return;

    col.addEventListener("mouseenter", ()=> renderCoveragePanel(r, teamId));
    col.addEventListener("mouseleave", ()=> renderCoveragePanel(selectedRow, selTeam));
    col.addEventListener("click", ()=>{
      const sel = $("teamSel");
      if (sel){
        sel.value = teamId;
        render();
      }
    });
  });

  // Cobertura inicial = equipe selecionada
  renderCoveragePanel(selectedRow || ordered[0], selTeam || teamKey(ordered[0]));

  strip.style.display = "flex";
}

function renderProjectStrip(projectId, row){
  if (!$("projectStrip")) return;
  if (!projectId){
    $("projectStrip").style.display = "none";
    return;
  }
  renderProjectRankBoard(projectId, row);
}

function render(){
  const row = currentRow();
  if (!row){ return; }

  const ae = safeParseFloat(row.ae_bn_mean);
  const at = safeParseFloat(row.AT_cont);
  const ac = safeParseFloat(row.AC_cont);
  const dist = parseDistAE(row.dist_AE);

  // KPIs
  setText("kpiAE", fmt(ae, 6));
  setText("kpiAT", fmt(at, 6));
  setText("kpiAC", fmt(ac, 6));

  const aeTier = nearestTier(ae);
  setHTML("kpiAETier", `tier ≈ <span class="mono">${aeTier.tier}</span> (centroide ${fmt(aeTier.centroid,1)})`);

  const atTier = nearestTier(at);
  setHTML("kpiATTier", `tier ≈ <span class="mono">${atTier.tier}</span>`);

  const acTier = nearestTier(ac);
  setHTML("kpiACTier", `tier ≈ <span class="mono">${acTier.tier}</span>`);

  // Charts
  drawBars($("aeBars"), dist, COLORS[0]);
  setText("aeMeta", `team=${row.team_id} | rank=${row.rank_bn}`);

  drawAxis($("axisBars"), at, ac, COLORS[0]);

  // Graph labels
  setText("valAT", `AT_cont=${fmt(at,6)} | tier≈${atTier.tier}`);
  setText("valAC", `AC_cont=${fmt(ac,6)} | tier≈${acTier.tier}`);
  setText("valAE", `AE_mean=${fmt(ae,6)} | tier≈${aeTier.tier}`);

  // ===== Detalhes por nó (VL..VH) =====
  // Se existir dist_Dom/dist_Eco/dist_Ling/dist_AT/dist_AC no CSV, usa.
  // Se não existir: Dom/Eco/Ling usa 1-hot pelo tier; AT/AC usa aproximação pelo contínuo.

  // preferir *_tier do CSV (evita pegar row.dominio/ecossistema/linguagens com strings tipo "web", "react", etc)
  const domTier  = row.dominio_tier ?? row.Dom ?? row.dom ?? row.DOM ?? "VH";
  const ecoTier  = row.ecossistema_tier ?? row.Eco ?? row.eco ?? row.ECO ?? "VH";
  const lingTier = row.linguagens_tier ?? row.Ling ?? row.ling ?? row.LING ?? "VH";

  const domScore  = safeParseFloat(row.dominio_score);
  const ecoScore  = safeParseFloat(row.ecossistema_score);
  const lingScore = safeParseFloat(row.linguagens_score);

  const distDom  = row.dist_Dom  ? parseDistAE(row.dist_Dom)  : distFromTierScore(domTier,  domScore);
  const distEco  = row.dist_Eco  ? parseDistAE(row.dist_Eco)  : distFromTierScore(ecoTier,  ecoScore);
  const distLing = row.dist_Ling ? parseDistAE(row.dist_Ling) : distFromTierScore(lingTier, lingScore);


  const distAT = row.dist_AT ? parseDistAE(row.dist_AT) : distFromCont(at);
  const distAC = row.dist_AC ? parseDistAE(row.dist_AC) : distFromCont(ac);
  const distAE2 = dist; // já veio do dist_AE

  // pinta mini gráficos (se os SVGs existirem)
  if ($("distDom"))  drawMiniBars($("distDom"), distDom, COLORS[0]);
  if ($("distEco"))  drawMiniBars($("distEco"), distEco, COLORS[0]);
  if ($("distLing")) drawMiniBars($("distLing"), distLing, COLORS[0]);
  if ($("distAT"))   drawMiniBars($("distAT"), distAT, COLORS[0]);
  if ($("distAC"))   drawMiniBars($("distAC"), distAC, COLORS[0]);
  if ($("distAE2"))  drawMiniBars($("distAE2"), distAE2, COLORS[0]);

  if ($("metaDomDist"))  setText("metaDomDist", row.dist_Dom ? "do CSV" : "1-hot (tier)");
  if ($("metaEcoDist"))  setText("metaEcoDist", row.dist_Eco ? "do CSV" : "1-hot (tier)");
  if ($("metaLingDist")) setText("metaLingDist", row.dist_Ling ? "do CSV" : "1-hot (tier)");
  if ($("metaATDist"))   setText("metaATDist", row.dist_AT ? "do CSV" : "aprox. pelo AT_cont");
  if ($("metaACDist"))   setText("metaACDist", row.dist_AC ? "do CSV" : "aprox. pelo AC_cont");
  if ($("metaAEDist2"))  setText("metaAEDist2", "dist_AE");

  // PC distribution (prefer dist_PC, senão tenta colunas PC_VL..PC_VH, senão usa aproximação a partir de AC)
  let distPC = null;
  if (row.dist_PC) distPC = parseDistAE(row.dist_PC);
  else if (row.PC_VL !== undefined && row.PC_L !== undefined && row.PC_M !== undefined && row.PC_H !== undefined && row.PC_VH !== undefined){
    const nums = [row.PC_VL,row.PC_L,row.PC_M,row.PC_H,row.PC_VH].map(safeParseFloat);
    const s = nums.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
    distPC = (s>0)? nums.map(v=>(Number.isFinite(v)?v:0)/s) : [0,0,0,0,0];
  } else {
    distPC = distAC; // fallback visual
  }

  // Renderiza a rede (com setas + gráficos dentro dos nós)
  renderBNGraph(row, {
    dom: distDom, eco: distEco, ling: distLing, pc: distPC, at: distAT, ac: distAC, ae: distAE2,
    metaDom:  row.dist_Dom  ? "dist_Dom"  : `${String(domTier).trim()} ${(Number.isFinite(domScore)? domScore*100 : 0).toFixed(0)}%`,
    metaEco:  row.dist_Eco  ? "dist_Eco"  : `${String(ecoTier).trim()} ${(Number.isFinite(ecoScore)? ecoScore*100 : 0).toFixed(0)}%`,
    metaLing: row.dist_Ling ? "dist_Ling" : `${String(lingTier).trim()} ${(Number.isFinite(lingScore)? lingScore*100 : 0).toFixed(0)}%`,

    metaPC: row.dist_PC ? "dist_PC" : (row.PC_VL!==undefined ? "PC_VL..PC_VH" : "fallback"),
  });

  // Comparativo do projeto (todas as equipes)
  const pid = (document.getElementById('projectSel') ? document.getElementById('projectSel').value : null);
  if (pid) renderProjectComparison(pid);
  if (pid) renderProjectStrip(pid, row);

// Dom/Eco/Ling discretos (se você adicionar colunas no CSV, eles aparecem)
  const dom = row.Dom ?? row.dom ?? row.DOM ?? row.dominio ?? row.dominio_tier ?? "VH (ex.)";
  const eco = row.Eco ?? row.eco ?? row.ECO ?? row.ecossistema ?? row.ecossistema_tier ?? "VH (ex.)";
  const ling = row.Ling ?? row.ling ?? row.LING ?? row.linguagens ?? row.linguagens_tier ?? "VH (ex.)";
  setText("valDom", String(dom));
  setText("valEco", String(eco));
  setText("valLing", String(ling));
  
  // Table
  renderRowTable(row);
}

function onProjectChange(){
  const p = $("projectSel").value;
  const teams = IDX.teamsByProject.get(p) || [];
  fillSelect($("teamSel"), teams);
  render();
}

function onTeamChange(){
  render();
}

/* =======================
   Load / Save
   ======================= */
function loadFromText(text, name="(arquivo)"){
  try{
    const parsed = parseTextToRows(text);
    if (!parsed.rows.length) throw new Error("Arquivo sem linhas de dados.");
    COLUMNS = parsed.cols;

    // normaliza nomes esperados
    DATA = parsed.rows.map(r => ({
      ...r,
      projeto_id: r.projeto_id ?? r.project_id ?? r.project ?? "",
      team_id: r.team_id ?? r.team ?? r.teamId ?? "",
      team_str: r.team_str ?? r.team ?? "",
      ae_bn_mean: r.ae_bn_mean ?? r.AE_mean ?? r.ae_mean ?? "",
      rank_bn: r.rank_bn ?? r.rank ?? "",
      AT_cont: r.AT_cont ?? r.at_cont ?? r.AT ?? "",
      AC_cont: r.AC_cont ?? r.ac_cont ?? r.AC ?? "",
      dist_AE: r.dist_AE ?? r.AE_dist ?? r.dist_ae ?? "",
    }));

    buildIndex();

    // selects
    fillSelect($("projectSel"), IDX.projects);
    const first = pickFirst();
    $("projectSel").value = first.p;
    onProjectChange();
    $("teamSel").value = first.t;
    render();

    // persist
    localStorage.setItem("bn_dash_last_text", text);
    localStorage.setItem("bn_dash_last_name", name);

    setMessage("msg", `Carregado: ${name} | linhas: ${DATA.length} | projetos: ${IDX.projects.length}`);
  }catch(e){
    console.error(e);
    setMessage("err", "Falha ao ler arquivo: " + (e?.message || e));
  }
}
let DETAILS = new Map();

function makeKey(pid, tid){
  return String(pid ?? "").trim() + "||" + String(tid ?? "").trim();
}

function loadDetailsFromText(text, name="(detalhes)"){
  const parsed = parseTextToRows(text);
  DETAILS = new Map();

  for (const r of parsed.rows){
    const pid = r.projeto_id ?? r.project_id ?? "";
    const tid = r.equipe_id ?? r.team_id ?? "";
    if (!pid || !tid) continue;
    DETAILS.set(makeKey(pid, tid), r);
  }

  localStorage.setItem("bn_dash_details_text", text);
  localStorage.setItem("bn_dash_details_name", name);

  render();
}

function getDetailsForRow(row){
  if (!row) return null;
  return DETAILS.get(makeKey(row.projeto_id, row.team_id)) || null;
}



function loadSample(){
  const sample = [
    "projeto_id\tteam_id\tteam_str\tae_bn_mean\trank_bn\tAT_cont\tAC_cont\tdist_AE",
    "P1\tP1-TEAM0\t[Dev169;Dev27;Dev81;Dev363]\t0.284741\t2\t0.249664\t0.333333\t0.243464,0.591790,0.162324,0.002421,0.000001",
    "P1\tP1-TEAM1\t[Dev10;Dev11;Dev12;Dev13]\t0.612300\t1\t0.700000\t0.500000\t0.010000,0.090000,0.220000,0.420000,0.260000",
    "P2\tP2-TEAM0\t[Dev20;Dev21;Dev22;Dev23]\t0.402000\t3\t0.500000\t0.300000\t0.060000,0.200000,0.500000,0.200000,0.040000"
  ].join("\\n");
  loadFromText(sample, "exemplo.tsv");
}

function clearAll(){
  DATA = []; COLUMNS = []; IDX = {projects:[], teamsByProject:new Map()};
  setHTML("projectSel", ""); setHTML("teamSel", "");
  setText("kpiAE", "—"); setText("kpiAT", "—"); setText("kpiAC", "—");
  setText("kpiAETier", "—"); setText("kpiATTier", "—"); setText("kpiACTier", "—");
  svgClear($("aeBars")); svgClear($("axisBars"));
  setText("valAT", "—"); setText("valAC", "—"); setText("valAE", "—");
  setText("valDom", "—"); setText("valEco", "—"); setText("valLing", "—");
  setHTML("rowTable", "");
  localStorage.removeItem("bn_dash_last_text");
  localStorage.removeItem("bn_dash_last_name");
  setMessage("msg","Dados limpos.");
}

/* im
   Wire up
   ======================= */
$("projectSel").addEventListener("change", onProjectChange);
$("teamSel").addEventListener("change", onTeamChange);

$("fileInput").addEventListener("change", async (ev) => {
  const file = ev.target.files?.[0];
  if (!file) return;
  const text = await file.text();
  loadFromText(text, file.name);
  ev.target.value = ""; // permite reimportar mesmo arquivo
});
const fileDetailsEl = document.getElementById("fileDetails");
if (fileDetailsEl) {
  fileDetailsEl.addEventListener("change", async (ev) => {
    const file = ev.target.files?.[0];
    if (!file) return;
    const text = await file.text();
    loadDetailsFromText(text, file.name);
    ev.target.value = "";
  });
}



$("btnSample").addEventListener("click", loadSample);
$("btnClear").addEventListener("click", clearAll);

attachNodeTooltips();



// CSV remoto (GitHub Raw, Gist Raw, etc.)
//const DATA_URL = "https://raw.githubusercontent.com/Felipeomc/dashboard_teams/refs/heads/main/Resultados_bn.csv";
const DATA_URL = "https://raw.githubusercontent.com/Felipeomc/dashboard_teams/main/Resultados_bn.csv";

async function loadFromUrl(url, name = "csv_remoto"){
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const text = await res.text();
  loadFromText(text, name);
}

// bootstrap: primeiro tenta GitHub; se falhar, usa localStorage; se não tiver, sample
const last = localStorage.getItem("bn_dash_last_text");
const lastName = localStorage.getItem("bn_dash_last_name") || "(último arquivo)";

loadFromUrl(DATA_URL, "Resultados_bn.csv (GitHub RAW)")
  .catch((e) => {
    console.error("Falha ao carregar GitHub:", e);

    if (last) loadFromText(last, lastName);
    else loadSample();
  });



function buildDistForRow(row){
  const at = safeParseFloat(row.AT_cont);
  const ac = safeParseFloat(row.AC_cont);
  const distAE = row.dist_AE ? parseDistAE(row.dist_AE) : [0,0,0,0,0];
  const distAT = row.dist_AT ? parseDistAE(row.dist_AT) : distFromCont(at);
  const distAC = row.dist_AC ? parseDistAE(row.dist_AC) : distFromCont(ac);

  const domTier  = row.Dom ?? row.dom ?? row.DOM ?? row.dominio ?? row.dominio_tier ?? "VH";
  const ecoTier  = row.Eco ?? row.eco ?? row.ECO ?? row.ecossistema ?? row.ecossistema_tier ?? "VH";
  const lingTier = row.Ling ?? row.ling ?? row.LING ?? row.linguagens ?? row.linguagens_tier ?? "VH";

  const distDom = row.dist_Dom ? parseDistAE(row.dist_Dom) : distFromTier(domTier);
  const distEco = row.dist_Eco ? parseDistAE(row.dist_Eco) : distFromTier(ecoTier);
  const distLing= row.dist_Ling? parseDistAE(row.dist_Ling): distFromTier(lingTier);

  let distPC = null;
  if (row.dist_PC) distPC = parseDistAE(row.dist_PC);
  else if (row.PC_VL !== undefined && row.PC_L !== undefined && row.PC_M !== undefined && row.PC_H !== undefined && row.PC_VH !== undefined){
    const nums = [row.PC_VL,row.PC_L,row.PC_M,row.PC_H,row.PC_VH].map(safeParseFloat);
    const s = nums.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
    distPC = (s>0)? nums.map(v=>(Number.isFinite(v)?v:0)/s) : [0,0,0,0,0];
  } else distPC = distAC;

  return {distAT, distAC, distAE, distDom, distEco, distLing, distPC};
}

function drawProjectGrouped(svg, teams){
  if (!svg) return;
  svgClear(svg);

  const {W,H} = syncViewBox(svg, 760, 260);

  // Mais compacto (e evita texto sobreposto quando as barras ficam finas)
  const padL=66, padR=16, padT=18, padB=28;
  const innerW=W-padL-padR, innerH=H-padT-padB;

  const tiers=["VL","L","M","H","VH"];
  const rowH = innerH/tiers.length;

  const k = Math.max(1, teams.length || 1);
  const barH = Math.max(7, (rowH-6)/k);

  // Escala ABSOLUTA 0..100% (não “estica” quando o máximo é < 1)
  const maxVal = 1.0;

  // fontes dinâmicas (pra não “invadir” quando barH fica pequeno)
  const tierFont = clamp(rowH*0.45, 10, 15);
  const pctFont  = clamp(barH*1.15, 9, 12);
  const legendFont = 11;

  // grade + rótulos de faixa
  for (let r=0;r<tiers.length;r++){
    const yMid = padT + r*rowH + rowH/2;

    const lab = svgEl("text",{
      x:padL-10, y:yMid,
      "text-anchor":"end",
      "dominant-baseline":"middle",
      fill:"#4b5563",
      "font-size": tierFont,
      "font-family":"ui-monospace"
    });
    lab.textContent = tiers[r];
    svg.appendChild(lab);

    svg.appendChild(svgEl("line",{
      x1:padL, y1:padT+r*rowH,
      x2:W-padR, y2:padT+r*rowH,
      stroke:"#eef2f7"
    }));
  }
  svg.appendChild(svgEl("line",{x1:padL,y1:padT+innerH,x2:W-padR,y2:padT+innerH,stroke:"#d7dde6"}));

  // barras (por faixa, com uma barra por equipe)
  for (let r=0;r<tiers.length;r++){
    for (let i=0;i<k;i++){
      const t = teams[i] || {};
      const v = (t.dist && Number.isFinite(t.dist[r])) ? t.dist[r] : 0;
      const bw = clamp(v/maxVal, 0, 1) * innerW;

      const x = padL;
      const y = padT + r*rowH + i*barH + 1;

      svg.appendChild(svgEl("rect",{
        x, y,
        width: bw,
        height: Math.max(1, barH-1),
        rx:"5", ry:"5",
        fill: t.color || "#94a3b8",
        opacity:"0.95"
      }));

      // rótulo de %: dentro se couber, senão fora (pra não sobrepor)
      const pct = (v*100).toFixed(0) + "%";
      const inside = bw >= 28;
      const tx = inside ? (x + bw - 4) : (x + bw + 4);
      const ta = inside ? "end" : "start";
      const fc = inside ? "#0b1220" : "#4b5563";

      const txt = svgEl("text",{
        x: tx,
        y: y + (barH-1)/2,
        "text-anchor": ta,
        "dominant-baseline":"middle",
        fill: fc,
        "font-size": pctFont,
        "font-family":"ui-monospace"
      });
      txt.textContent = pct;
      svg.appendChild(txt);
    }
  }

  // legenda (embaixo)
  // legenda (embaixo) — com wrap (quebra linha quando não cabe)
  let cursor = padL;
  let ly = H - 10;
  const lineH = 14;

  teams.forEach((t)=>{
    const label = String(t.label || "");
    const est = 13 + (label.length * 6) + 18; // largura estimada do item

    // se não cabe, quebra para a linha de cima
    if (cursor + est > W - padR){
      cursor = padL;
      ly -= lineH;
    }

    svg.appendChild(svgEl("rect",{
      x: cursor, y: ly-9, width: 9, height: 9, rx:"2", ry:"2",
      fill: t.color || "#94a3b8"
    }));

    const tt = svgEl("text",{
      x: cursor+13, y: ly-1,
      fill:"#4b5563",
      "font-size": legendFont,
      "font-family":"ui-monospace"
    });
    tt.textContent = label;
    svg.appendChild(tt);

    cursor += est;
  });

}


function drawProjectGroupedIntoGroup(g, W, H, teams, label){
  const padL=90, padR=16, padT=22, padB=6;
  const innerW=W-padL-padR, innerH=H-padT-padB;
  const tiers=["VL","L","M","H","VH"];
  const rowH = innerH/tiers.length;
  const k = teams.length || 1;
  const barH = Math.max(6, (rowH-6)/Math.max(1,k));
  const maxVal = Math.max(0.001, ...teams.flatMap(t=>t.dist));

  const tt = svgEl("text",{x:12,y:16,fill:"#0b1220","font-size":"20","font-weight":"800","font-family":"ui-sans-serif"});
  tt.textContent = label;
  g.appendChild(tt);

  for (let r=0;r<tiers.length;r++){
    const yMid = padT + r*rowH + rowH/2 + 4;
    const lab = svgEl("text",{x:padL-8,y:yMid,"text-anchor":"end",fill:"#6b7280","font-size":"10","font-family":"ui-monospace"});
    lab.textContent = tiers[r];
    g.appendChild(lab);

    for (let i=0;i<k;i++){
      const v = teams[i].dist[r] || 0;
      const bw = (v/maxVal) * innerW;
      const x = padL;
      const y = padT + r*rowH + i*barH + 1;
      g.appendChild(svgEl("rect",{x,y,width:bw,height:barH-1,rx:"5",ry:"5",fill:teams[i].color,opacity:"0.95"}));
    }
  }
}

/* =======================
   Radar por equipe (OSF / SLF / #Projetos em comum)
   ======================= */
function clamp01(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return 0;
  return Math.max(0, Math.min(1, n));
}

/* ===== PATCH: OSF/SLF por projeto ÚNICO (dedup por PID) =====
   - Proj: #PIDs distintos (continua igual)
   - OSF/SLF: média por PID (se P179 aparece 2x, conta 1 vez)
*/
function extractTeamCollabStats(obj){
  const base = (obj && obj.row) ? obj.row : obj;
  const det  = (typeof getDetailsForRow === "function") ? getDetailsForRow(base) : null;
  const row  = det || base;

  const cols = ["note_dev1","note_dev2","note_dev3","note_dev4","note_dev5"];
  const txt = cols
    .map(c => (row && row[c]) ? String(row[c]) : "")
    .filter(s => s && s.trim())
    .join("\n");

  // PIDs distintos (Proj)
  const pidSet = new Set((txt.match(/\bP\d+\b/gi) || []).map(p => p.toUpperCase()));

  // Mapa PID -> {osf, slf} (dedup)
  const pidMap = new Map();
  const re = /\b(P\d+)\b\s*\([^)]*?\bosf\b\s*[:=]\s*([0-9]*[.,]?[0-9]+)[^)]*?\bslf\b\s*[:=]\s*([0-9]*[.,]?[0-9]+)/gi;

  for (const m of txt.matchAll(re)){
    const pid = String(m[1]).toUpperCase();
    const osf = parseFloat(String(m[2]).replace(",", "."));
    const slf = parseFloat(String(m[3]).replace(",", "."));
    if (Number.isFinite(osf) && Number.isFinite(slf) && !pidMap.has(pid)){
      pidMap.set(pid, { osf, slf }); // pega o 1º e ignora duplicatas
    }
  }

  // OSF/SLF por PID (único).
  let osfMean = 0, slfMean = 0;

  if (pidMap.size){
    let so = 0, ss = 0;
    for (const v of pidMap.values()){
      so += v.osf; ss += v.slf;
    }
    osfMean = so / pidMap.size;
    slfMean = ss / pidMap.size;
  } else {
    // fallback se não houver PIDs com osf/slf
    const osfs = [];
    const slfs = [];
    for (const m of txt.matchAll(/\bosf\b\s*[:=]\s*([0-9]*[.,]?[0-9]+)/gi)){
      const v = parseFloat(String(m[1]).replace(",", "."));
      if (Number.isFinite(v)) osfs.push(v);
    }
    for (const m of txt.matchAll(/\bslf\b\s*[:=]\s*([0-9]*[.,]?[0-9]+)/gi)){
      const v = parseFloat(String(m[1]).replace(",", "."));
      if (Number.isFinite(v)) slfs.push(v);
    }
    osfMean = osfs.length ? (osfs.reduce((a,b)=>a+b,0)/osfs.length) : 0;
    slfMean = slfs.length ? (slfs.reduce((a,b)=>a+b,0)/slfs.length) : 0;
  }

  return { osfMean, slfMean, nCommon: pidSet.size };
}



function drawRadar(svg, values, labels, color){
  if(!svg) return;
  svgClear(svg);

  const vb = (svg.getAttribute("viewBox")||"0 0 220 220").split(" ").map(Number);
  const W = vb[2], H = vb[3];
  const cx = W/2, cy = H/2 + 6;
  const R  = Math.min(W,H) * 0.34; // ~75

  const N = labels.length;
  const levels = 4;
  const a0 = -Math.PI/2;

  function pt(i, s){
    const ang = a0 + i*(2*Math.PI/N);
    return { x: cx + s*R*Math.cos(ang), y: cy + s*R*Math.sin(ang) };
  }

  // grid
  for (let l=1; l<=levels; l++){
    const s = l/levels;
    const pts = [];
    for (let i=0; i<N; i++){
      const p = pt(i,s);
      pts.push(`${p.x.toFixed(1)},${p.y.toFixed(1)}`);
    }
    svg.appendChild(svgEl("polygon", { points: pts.join(" "), fill:"none", stroke:"#e5e7eb", "stroke-width":"1" }));
  }

  // axes
  for (let i=0; i<N; i++){
    const p = pt(i,1);
    svg.appendChild(svgEl("line", { x1:cx, y1:cy, x2:p.x, y2:p.y, stroke:"#cbd5e1", "stroke-width":"1" }));
  }

  // labels
  for (let i=0; i<N; i++){
    const p = pt(i,1.18);
    const t = svgEl("text", { x:p.x, y:p.y, fill:"#475569", "font-size":"16", "font-family":"ui-monospace" });
    t.setAttribute("text-anchor", (p.x < cx-10) ? "end" : (p.x > cx+10 ? "start" : "middle"));
    t.textContent = labels[i];
    svg.appendChild(t);
  }

  // polygon
  const poly = [];
  for (let i=0; i<N; i++){
    const v = clamp01(values[i]);
    const p = pt(i, v);
    poly.push(`${p.x.toFixed(1)},${p.y.toFixed(1)}`);
  }
  svg.appendChild(svgEl("polygon", { points: poly.join(" "), fill: color, opacity:"0.5", stroke: color, "stroke-width":"2" }));

  // vertices
  for (let i=0; i<N; i++){
    const v = clamp01(values[i]);
    const p = pt(i, v);
    svg.appendChild(svgEl("circle", { cx:p.x, cy:p.y, r:"3.4", fill: color }));
  }
  svg.appendChild(svgEl("circle", { cx, cy, r:"2.2", fill:"#0b1220" }));
}
renderTierOnly(domContainer, "Domínio (DOM)", row.dominio_tier, row.dominio_score);
renderTierOnly(ecoContainer, "Ecossistema (ECO)", row.ecossistema_tier, row.ecossistema_score);
renderTierOnly(lingContainer,"Linguagens (LING)", row.linguagens_tier, row.linguagens_score);

function renderProjectRadars(projectId, orderedRows){
  const grid = $("radarGrid");
  if (!grid) return;

  grid.innerHTML = "";

  const MAX_TEAMS = 5;
  const top = (orderedRows || []).slice(0, MAX_TEAMS);

  if (!top.length){
    grid.innerHTML = '<div class="mini">Sem equipes para este projeto.</div>';
    return;
  }

  const stats = top.map((r, idx)=>{
    const base = (r && r.row) ? r.row : r;
    const label = String(base.team_id || r.label || `TEAM${idx}`);
    const color = COLORS[idx % COLORS.length];
    const s = extractTeamCollabStats(r); // aceita base ou objeto com .row
    return { label, color, row: base, ...s };
  });


  const maxCommon = Math.max(1, ...stats.map(s=>s.nCommon));
  setText("projMetaRadar", `Proj normalizado por /${maxCommon}`);

  const selectedTeam = $("teamSel") ? String($("teamSel").value||"") : "";

  stats.forEach((t)=>{
    const card = document.createElement("div");
    card.className = "radarItem" + ((String(t.label)===selectedTeam) ? " active" : "");
    card.innerHTML = `
      <div class="radarHead">
        <span class="dot" style="background:${t.color}"></span>
        <span class="mono">${escapeHtml(t.label)}</span>
      </div>
      <svg class="radarSvg" viewBox="0 0 220 220"></svg>
      <div class="radarKpis">
        <div><span class="k">OSF</span><span class="v mono">${fmt(t.osfMean,3)}</span></div>
        <div><span class="k">SLF</span><span class="v mono">${fmt(t.slfMean,3)}</span></div>
        <div><span class="k">Proj</span><span class="v mono">${t.nCommon}</span></div>
      </div>
    `;
    grid.appendChild(card);

    const svg = card.querySelector("svg");
    drawRadar(svg,
      [
        clamp01(t.osfMean),
        clamp01(t.slfMean),
        clamp01(t.nCommon / maxCommon)
      ],
      ["OSF","SLF","Proj"],
      t.color
    );

    // clique no radar => seleciona a equipe
    card.addEventListener("click", ()=>{
      const sel = $("teamSel");
      if (sel){
        sel.value = t.label;
        render(); // já existe no seu arquivo
      }
    });
  });
}


function renderProjectComparison(projectId){
  if (!DATA || DATA.length===0) return;
  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||"")===String(projectId));
  if (rows.length===0) return;

  const ordered = rows.slice().sort((a,b)=>{
    const ra = safeParseFloat(a.rank_bn); const rb = safeParseFloat(b.rank_bn);
    if (Number.isFinite(ra) && Number.isFinite(rb)) return ra-rb;
    return String(a.team_id||"").localeCompare(String(b.team_id||""));
  });

  const MAX_TEAMS = 5;
  const teams = ordered.slice(0, MAX_TEAMS).map((r, idx)=>{
    const label = String(r.team_id||`TEAM${idx}`);
    const color = COLORS[idx % COLORS.length];
    const d = buildDistForRow(r);
    return { label, color, row: r, ...d }; // <-- adiciona row:r
  });
    // Radars (OSF / SLF / #Projetos em comum)
  renderProjectRadars(projectId, ordered.slice(0, MAX_TEAMS));

  
  
  drawProjectGrouped($("projAT"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAT})));
  drawProjectGrouped($("projAC"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAC})));
  drawProjectGrouped($("projAE"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAE})));

  

  renderProjectTech(projectId, teams);
  renderProjectTechOcc(projectId, teams);



}

function renderProjectTech(projectId, teamsPrebuilt=null){
  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||"")===String(projectId));
  if (rows.length===0) return;

  const teams = teamsPrebuilt ?? rows.map((r, idx)=>{
    const label = String(r.team_id||`TEAM${idx}`);
    const color = COLORS[idx % COLORS.length];
    const d = buildDistForRow(r);
    return {label,color,...d};
  });
  // Se existir a versão em painéis (Dom/Eco/Ling/PC separados), usa ela
  const domEl = $("projDOM"), ecoEl = $("projECO"), lingEl = $("projLING"), pcEl = $("projPC");
  if (domEl && ecoEl && lingEl){
    drawProjectGrouped(domEl, teams.map(t=>({label:t.label,color:t.color,dist:t.distDom})));
    drawProjectGrouped(ecoEl, teams.map(t=>({label:t.label,color:t.color,dist:t.distEco})));
    drawProjectGrouped(lingEl, teams.map(t=>({label:t.label,color:t.color,dist:t.distLing})));
    if (pcEl) drawProjectGrouped(pcEl, teams.map(t=>({label:t.label,color:t.color,dist:t.distPC})));
    return;
  }

  const svg = $("projTech");
  if (!svg) return;
  svgClear(svg);

  const vb = (svg.getAttribute("viewBox")||"0 0 760 260").split(" ").map(Number);
  const W=vb[2], H=vb[3];
  const blocks = [
    {label:"Dom", distKey:"distDom"},
    {label:"Eco", distKey:"distEco"},
    {label:"Ling", distKey:"distLing"},
    {label:"PC", distKey:"distPC"},
  ];
  const blockH = H/blocks.length;

  blocks.forEach((b, bi)=>{
    const g = svgEl("g",{transform:`translate(0,${bi*blockH})`});
    svg.appendChild(g);
    drawProjectGroupedIntoGroup(g, W, blockH, teams.map(t=>({label:t.label,color:t.color,dist:t[b.distKey]})), b.label);
    if (bi<blocks.length-1){
      svg.appendChild(svgEl("line",{x1:12,y1:(bi+1)*blockH,x2:W-12,y2:(bi+1)*blockH,stroke:"#eef2f7"}));
    }
  });

  // legend (limit to 10 to avoid overflow)
  let cursor = 110;
  const ly = H-6;
  teams.slice(0,10).forEach((t)=>{
    svg.appendChild(svgEl("rect",{x:cursor,y:ly-10,width:10,height:10,rx:"2",ry:"2",fill:t.color}));
    const tt = svgEl("text",{x:cursor+14,y:ly-1,fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    tt.textContent = t.label;
    svg.appendChild(tt);
    cursor += 14 + (t.label.length*7) + 16;
  });
}
function renderProjectTechOcc(projectId, teams){
  const svg  = $("projTechOcc");
  const txt  = $("techTargetsText");
  const meta = $("projMetaTechOcc");
  if(!svg) return;

  svgClear(svg);

  if(!teams || !teams.length){
    if(meta) meta.textContent = "sem equipes";
    if(txt) txt.textContent = "";
    return;
  }

  const dims = [
    {prefix:"dominio",     label:"DOM"},
    {prefix:"ecossistema", label:"ECO"},
    {prefix:"linguagens",  label:"LING"},
  ];
  const kinds = [
    {k:"m", label:"M"},
    {k:"s", label:"S"},
    {k:"c", label:"C"},
  ];

  const anyCol = (p,k) => teams.some(t=>{
    const r = t.row || {};
    return (r[`${p}_${k}_covered_list`] !== undefined) || (r[`${p}_${k}_covered`] !== undefined);
  });
  const hasAny = dims.some(d => kinds.some(kk => anyCol(d.prefix, kk.k)));

  if(!hasAny){
    if(meta) meta.textContent = "Sem colunas *_covered_list no CSV.";
    if(txt) txt.textContent = "";
    const msg = svgEl("text",{x:20,y:40,fill:"#9fb0c0","font-size":"22","font-family":"ui-monospace"});
    msg.textContent = "Sem dados de tecnologias (adicione colunas *_covered_list no CSV).";
    svg.appendChild(msg);
    return;
  }

  // ===== pega listas alvo (se existirem) ou faz fallback pelo union do que apareceu nas Top-5
  const src = [
    getDetailsForRow(teams[0].row),
    teams[0].row, teams[1]?.row, teams[2]?.row
  ].filter(Boolean);

  function pickTargetList(srcObjs, prefix, kind){
    const candidates = [
      `${prefix}_${kind}_list`,
      `${prefix}_${kind}_target_list`,
      `${prefix}_${kind}_req_list`,
      `${prefix}_${kind}_required_list`,
      `${prefix}_${kind}_techs`,
      `${prefix}_${kind}_targets`,
    ];
    for(const obj of srcObjs){
      for(const c of candidates){
        const L = normalizeList(obj?.[c]);
        if(L.length) return L;
      }
    }

    // fallback: usa o que apareceu nas Top-5 (não mostra alvos 0/5 se ninguém cobriu)
    const out = new Set();
    for(const t of teams){
      const r = t.row || {};
      const total = safeInt(r[`${prefix}_${kind}_total`]);
      const list  = normalizeList(r[`${prefix}_${kind}_covered_list`]);
      const base  = total > 0 ? list.slice(0, Math.min(total, list.length)) : list;
      base.forEach(x => out.add(x));
    }
    return Array.from(out);
  }

  const targetsByDim = {};
  dims.forEach(d=>{
    targetsByDim[d.prefix] = {};
    kinds.forEach(kk=>{
      targetsByDim[d.prefix][kk.k] = pickTargetList(src, d.prefix, kk.k);
    });
  });

  // texto “DOM M[...] S[...] C[...] | ECO ...”
  if(txt){
    const fmtList = (arr)=> (arr && arr.length) ? arr.join(", ") : "—";
    const parts = dims.map(d=>{
      const m = targetsByDim[d.prefix].m;
      const s = targetsByDim[d.prefix].s;
      const c = targetsByDim[d.prefix].c;
      return `${d.label}  M[${fmtList(m)}]  S[${fmtList(s)}]  C[${fmtList(c)}]`;
    });
    txt.textContent = parts.join("   |   ");
  }

  function normKey(x){ return String(x||"").trim().toLowerCase(); }

  // itens por dimensão
  const itemsByDim = dims.map(d=>{
    const itemMap = new Map();
    const tierRank = {M:3,S:2,C:1};

    kinds.forEach(kk=>{
      (targetsByDim[d.prefix][kk.k] || []).forEach(name=>{
        const key = normKey(name);
        if(!key) return;
        if(!itemMap.has(key)){
          itemMap.set(key, {name:String(name).trim(), tier:kk.label, teamIdxs:new Set()});
        } else {
          const it = itemMap.get(key);
          if(tierRank[kk.label] > tierRank[it.tier]) it.tier = kk.label;
        }
      });
    });

    for(const [key,it] of itemMap){
      teams.forEach((t, idx)=>{
        const r = t.row || {};
        let hit = false;
        for(const kk of kinds){
          const L = normalizeList(r[`${d.prefix}_${kk.k}_covered_list`]);
          if(L.some(x => normKey(x) === key)){ hit = true; break; }
        }
        if(hit) it.teamIdxs.add(idx);
      });
    }

    const arr = Array.from(itemMap.values()).map(it=>({
      ...it,
      teamIdxs: Array.from(it.teamIdxs),
      count: it.teamIdxs.size
    }));
    arr.sort((a,b)=> (b.count-a.count) || a.name.localeCompare(b.name));
    return {dim:d, items:arr};
  });

  // ===== desenhar (layout profissional): 3 colunas (M/S/C) por linha (DOM/ECO/LING),
  // bolha com anel segmentado por equipe + sombra suave.
  const {W,H} = syncViewBox(svg, 760, 340);
  // defs (shadow)
  const defs = svgEl("defs",{});
  const flt = svgEl("filter",{id:"shadowSoft",x:"-20%",y:"-20%",width:"140%",height:"140%"});
  flt.appendChild(svgEl("feDropShadow",{dx:"0",dy:"1.2",stdDeviation:"1.6","flood-color":"#000","flood-opacity":"0.10"}));
  defs.appendChild(flt);
  svg.appendChild(defs);

  const padL=78, padR=14, padT=14, padB=52;
  const rowGap=16;
  const colGap=12;

  const rowH = (H - padT - padB - rowGap*2) / 3;
  const colW = (W - padL - padR - colGap*2) / 3;

  const tierOrder = ["M","S","C"];
  const tierTitle = {M:"Must (M)", S:"Should (S)", C:"Could (C)"};

  const maxCount = Math.max(1, ...itemsByDim.flatMap(g=>g.items.map(it=>it.count)));

  function rForCount(c){
    const rMax = Math.min(34, rowH*0.22);
    const rMin = Math.min(18, rMax-6);
    if(maxCount<=1) return rMin;
    return rMin + (c-1)/(maxCount-1)*(rMax-rMin);
  }
  function shortLabel(s, n=14){
    const t = String(s||"");
    return (t.length<=n) ? t : (t.slice(0, n-1) + "…");
  }
  function arcPath(cx,cy,r,a0,a1){
    const x0 = cx + r*Math.cos(a0), y0 = cy + r*Math.sin(a0);
    const x1 = cx + r*Math.cos(a1), y1 = cy + r*Math.sin(a1);
    const large = ((a1-a0) % (Math.PI*2)) > Math.PI ? 1 : 0;
    return `M ${x0} ${y0} A ${r} ${r} 0 ${large} 1 ${x1} ${y1}`;
  }

  // header de colunas
  tierOrder.forEach((T, ci)=>{
    const x = padL + ci*(colW+colGap);
    const y = padT;

    const bg = svgEl("rect",{x, y, width:colW, height:26, rx:10, ry:10, fill:"#f3f6fb", stroke:"#e5e7eb"});
    svg.appendChild(bg);

    const tt = svgEl("text",{x:x+10,y:y+18,fill:"#334155","font-size":"14","font-weight":"800","font-family":"ui-sans-serif"});
    tt.textContent = tierTitle[T];
    svg.appendChild(tt);
  });

  // linhas DOM/ECO/LING
  itemsByDim.forEach((g, ri)=>{
    const y0 = padT + 32 + ri*(rowH + rowGap);

    // título da dimensão
    const dlab = svgEl("text",{x:16,y:y0+18,fill:"#0b1220","font-size":"22","font-weight":"900","font-family":"ui-sans-serif"});
    dlab.textContent = g.dim.label;
    svg.appendChild(dlab);

    // separador horizontal suave
    if(ri>0){
      svg.appendChild(svgEl("line",{x1:12,y1:y0-10,x2:W-12,y2:y0-10,stroke:"#eef2f7"}));
    }

    tierOrder.forEach((T, ci)=>{
      const x = padL + ci*(colW+colGap);
      const y = y0;

      // card do tier
      const card = svgEl("rect",{x, y, width:colW, height:rowH, rx:14, ry:14, fill:"#ffffff", stroke:"#e5e7eb"});
      svg.appendChild(card);

      // área interna
      const insetX = x + 12;
      const insetY = y + 14;
      const innerW = colW - 24;
      const innerH = rowH - 24;

      // itens desse tier
      const items = (g.items || []).filter(it=>it.tier===T);

      // flow layout
      let cx = insetX;
      let cy = insetY;
      let lineH = 0;

      items.forEach((it)=>{
        const r = rForCount(it.count);
        const needW = Math.max(2*r + 18, 86);
        const needH = 2*r + 30;

        if(cx + needW > insetX + innerW){
          cx = insetX;
          cy += lineH + 10;
          lineH = 0;
        }
        if(cy + needH > insetY + innerH){
          // se estourar, para de desenhar (evita bagunça visual)
          return;
        }

        const bx = cx + r;
        const by = cy + r;

        const gg = svgEl("g",{});
        const tip = svgEl("title",{});
        const teamNames = it.teamIdxs.map(i=>teams[i]?.label).filter(Boolean).join(", ");
        tip.textContent = `${it.name} | ${it.count}/${teams.length} equipes: ${teamNames || "—"}`;
        gg.appendChild(tip);

        // bolha base + sombra
        gg.appendChild(svgEl("circle",{
          cx:bx, cy:by, r,
          fill:"#fbfdff",
          stroke:"#cbd5e1",
          "stroke-width":"1.5",
          filter:"url(#shadowSoft)"
        }));

        // anel “slots” (um slot por equipe)
        const ringR = r + 4;
        gg.appendChild(svgEl("circle",{cx:bx,cy:by,r:ringR,fill:"none",stroke:"#e5e7eb","stroke-width":"6"}));

        const k = teams.length;
        const seg = (Math.PI*2) / Math.max(1,k);
        const gap = seg*0.18;
        for(let i=0;i<k;i++){
          if(!it.teamIdxs.includes(i)) continue;
          const a0 = -Math.PI/2 + i*seg + gap;
          const a1 = -Math.PI/2 + (i+1)*seg - gap;
          gg.appendChild(svgEl("path",{
            d: arcPath(bx,by,ringR,a0,a1),
            fill:"none",
            stroke: (teams[i]?.color || "#999"),
            "stroke-width":"6",
            "stroke-linecap":"round"
          }));
        }

        // contagem no centro
        const cTxt = svgEl("text",{
          x:bx,y:by+7,
          "text-anchor":"middle",
          fill:"#0b1220",
          "font-size": Math.max(16, r*1.05),
          "font-weight":"900",
          "font-family":"ui-sans-serif"
        });
        cTxt.textContent = String(it.count);
        gg.appendChild(cTxt);

        // label abaixo
        const lab = svgEl("text",{
          x:bx,y:by + r + 18,
          "text-anchor":"middle",
          fill:"#475569",
          "font-size":"13",
          "font-weight":"700",
          "font-family":"ui-sans-serif"
        });
        lab.textContent = shortLabel(it.name, 16);
        gg.appendChild(lab);

        svg.appendChild(gg);

        cx += needW;
        lineH = Math.max(lineH, needH);
      });
    });
  });

  // legenda das equipes
  let lx = padL;
  const ly = H - 18;
  teams.forEach((t)=>{
    svg.appendChild(svgEl("rect",{x:lx,y:ly-10,width:12,height:12,rx:"3",ry:"3",fill:t.color,stroke:"#0b1220","stroke-width":"0.4"}));
    const tx = svgEl("text",{x:lx+16,y:ly,fill:"#475569","font-size":"14","font-weight":"800","font-family":"ui-sans-serif"});
    tx.textContent = t.label;
    svg.appendChild(tx);
    lx += 16 + (t.label.length*7) + 18;
  });

  
}


</script>
</body>
</html>
