<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard BN — Team Fit (AT/AC/AE)</title>
  <style>
    :root{
      --bg:#ffffff; --card:#ffffff; --card2:#f6f8fb; --text:#0b1220; --muted:#4b5563;
      --line:#d7dde6; --accent:#2f6bff; --good:#1f9d55; --warn:#b45309; --bad:#b42318;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --r: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:var(--sans); background:var(--bg); color:var(--text);}
    header{padding:18px 18px 10px; position:sticky; top:0; background:rgba(255,255,255,.92); backdrop-filter: blur(8px); border-bottom:1px solid var(--line); z-index:10}
    h1{font-size:16px; margin:0 0 6px; font-weight:700; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px; margin:0}
    .wrap{padding:16px 18px 26px; max-width:1300px; margin:0 auto;}
    .grid{display:grid; gap:14px;}
    @media(min-width:1100px){ .grid{grid-template-columns: 1fr;} }
    .card{background:var(--card); border:1px solid var(--line); border-radius:var(--r); box-shadow:var(--shadow);}
    .card .hd{padding:12px 12px 10px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; justify-content:space-between}
    .card .hd strong{font-size:13px}
    .card .bd{padding:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{font-family:var(--mono); font-size:11px; color:var(--muted); border:1px solid var(--line); padding:6px 8px; border-radius:999px; background:var(--card2)}
    .btn{cursor:pointer; border:1px solid var(--line); background:linear-gradient(180deg,#ffffff, #f3f4f6);
         color:var(--text); padding:8px 10px; border-radius:12px; font-size:12px; font-weight:600;}
    .btn:hover{border-color:#2f425f}
    .btn:active{transform:translateY(1px)}
    input[type=file]{display:none}
    label.file{display:inline-flex; gap:8px; align-items:center}
    select{background:#ffffff; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:8px 10px; font-size:12px}
    .hint{color:var(--muted); font-size:12px; line-height:1.45; margin-top:8px}
    .kpis{
      display:flex;
      gap:12px;
      align-items:stretch;
      flex-wrap:nowrap;      /* não quebra linha */
    }

    .kpi{
      flex:1 1 0;            /* deixa os 3 dividirem o espaço */
      min-width:0;           /* IMPORTANTE: permite encolher */
    }
    .kpi{
      background:var(--card2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;

      display:grid;
      grid-template-columns: 1fr auto auto; /* titulo | valor | tier */
      align-items:baseline;
      column-gap:14px;
    }
    .kpi .t{font-size:11px; color:var(--muted); margin-bottom:6px}
    .kpi .v{font-family:var(--mono); font-size:16px; font-weight:700}
    .kpi .s{font-size:11px; color:var(--muted); margin-top:2px}
    .split{display:grid; gap:12px}
    @media(min-width:900px){ .split{grid-template-columns: 1fr 1fr;} }
    .svgbox{width:100%; overflow:auto; padding:8px 8px 2px}
    .mini{font-size:11px; color:var(--muted)}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{border-bottom:1px solid var(--line); padding:8px 6px; text-align:left; vertical-align:top}
    th{font-size:11px; color:var(--muted); font-weight:700}
    td code{font-family:var(--mono); font-size:11px; color:#0b1220}
    .barwrap{display:grid; gap:10px}
    .barcard{background:var(--card2); border:1px solid var(--line); border-radius:14px; padding:10px}
    .barcard .ttl{display:flex; justify-content:space-between; align-items:baseline; gap:10px}
    .barcard .ttl strong{font-size:12px}
    .barcard .ttl span{font-family:var(--mono); font-size:11px; color:var(--muted)}
    .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
    .leg{display:flex; align-items:center; gap:6px; font-size:11px; color:var(--muted)}
    .sw{width:10px; height:10px; border-radius:3px; background:#999}
    .foot{color:var(--muted); font-size:11px; margin-top:10px}
    .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    .mono{font-family:var(--mono)}
    .err{background:rgba(255,107,107,.08); border:1px solid rgba(255,107,107,.35); color:#0b1220; padding:10px; border-radius:14px; font-size:12px}
    .note{background:rgba(122,162,255,.08); border:1px solid rgba(122,162,255,.35); color:#0b1220; padding:10px; border-radius:14px; font-size:12px}
  
    /* Tooltip flutuante */
    .tooltip{
      position:fixed;
      pointer-events:none;
      z-index:9999;
      max-width:420px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#ffffff;
      color:var(--text);
      box-shadow: 0 12px 28px rgba(16,24,40,.18);
      font-size:12px;
      line-height:1.35;
      display:none;
    }
    .tooltip .tt-title{font-weight:800; margin-bottom:6px;}
    .formulaTag{cursor:help; text-decoration:underline; text-underline-offset:2px;}
    .tooltip .tt-mono{font-family:var(--mono); font-size:11px; color:var(--text); background:#f6f8fb; border:1px solid var(--line); padding:6px 8px; border-radius:12px; display:inline-block;}
    .tooltip .tt-muted{color:var(--muted); font-size:11px; margin-top:6px;}
    #bnGraphWrap{
      overflow:auto;
      border:1px solid #e5e7eb;
      border-radius:16px;
      background:#f8fafc;
      padding:10px;
      .detailsBox{
        margin-top:10px;
        border:1px solid var(--line);
        border-radius:14px;
        background:var(--card2);
        padding:12px;
      }
      .detailsBox .pre{white-space:pre-wrap; margin:0; font-family:var(--mono); font-size:12px; line-height:1.35;}
      .detailsBox .dt-label{font-size:12px; color:var(--muted); margin-bottom:4px; font-weight:700;}

    }
#bnGraph{ display:block; }
/* =======================
   STRIP FIXO (Projeto)
   ======================= */
.projectStrip{margin-top:10px; display:flex; gap:12px; align-items:stretch;}
@media(max-width:1000px){ .projectStrip{flex-direction:column;} }

.stripCard{
  background:var(--card2);
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px;
  min-width:0;
}

.stripTitle{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  font-size:11px;
  color:var(--muted);
  margin-bottom:8px;
}

.covRows{display:grid; gap:10px;}
.covRow{display:grid; grid-template-columns: 54px 1fr; gap:10px; align-items:flex-start;}
.covRow .dim{font-weight:900; font-size:12px; letter-spacing:.5px;}

.covStack{display:grid; gap:6px;}
.hbarLine{display:grid; grid-template-columns: 26px 1fr auto; gap:8px; align-items:center;}
.hbar{
  height:10px;
  background:#fff;
  border:1px solid var(--line);
  border-radius:999px;
  overflow:hidden;
}
.hbar > span{
  display:block; height:100%; width:0%;
  background:linear-gradient(90deg, rgba(47,107,255,.25), rgba(47,107,255,.85));
}
.hbarLine[data-kind="S"] .hbar > span{background:linear-gradient(90deg, rgba(31,157,85,.18), rgba(31,157,85,.75));}
.hbarLine[data-kind="C"] .hbar > span{background:linear-gradient(90deg, rgba(180,83,9,.18), rgba(180,83,9,.75));}
.hbarMeta{font-family:var(--mono); font-size:11px; color:var(--muted); white-space:nowrap;}

.techHint{font-size:11px; color:var(--muted); margin-top:2px; line-height:1.25;}
.techHint b{color:var(--text); font-weight:800;}

/* Ranking board */
.rankBoard{display:flex; gap:10px; align-items:flex-end; overflow-x:auto; padding-bottom:4px;}
.teamCol{
  flex:0 0 128px;
  border:1px solid var(--line);
  background:#fff;
  border-radius:14px;
  padding:8px;
  cursor:pointer;
}
.teamCol:hover{border-color:#2f6bff;}
.teamCol.active{outline:2px solid rgba(47,107,255,.35); border-color:#2f6bff;}

.teamName{
  font-size:11px;
  font-weight:900;
  margin-bottom:4px;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.teamDevs{
  font-family:var(--mono);
  font-size:10px;
  color:var(--muted);
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  margin-bottom:8px;
}

.vbars{display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:end; height:92px;}
.vbarBox{
  position:relative;
  height:92px;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  border-radius:10px;
  background:linear-gradient(180deg,#ffffff,#f3f4f6);
  border:1px solid var(--line);
  overflow:hidden;
}
.vbar{position:absolute; bottom:0; left:0; right:0; height:0%; background:rgba(47,107,255,.85);}
.vbar.expert{background:rgba(75,85,99,.85);}

.vnum{
  position:relative;
  z-index:2;
  font-family:var(--mono);
  font-size:12px;
  font-weight:900;
  color:#0b1220;
  padding:2px 6px;
  border-radius:999px;
  background:rgba(255,255,255,.92);
  border:1px solid var(--line);
  margin-bottom:6px;
}

.vlab{font-size:9px; color:var(--muted); margin-top:6px; display:flex; justify-content:space-between;}
.vlab span{width:50%; text-align:center;}
.topbar{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:16px;
}

.topbar h1{
  margin:0;
}

.top-controls{
  margin-top:0 !important;     /* mata o inline margin-top:10px */
  display:flex;
  gap:12px;
  justify-content:flex-end;
}

.top-controls select{
  min-width:140px;             /* opcional */
}

  </style>
</head>
<body>
<div id="tooltip" class="tooltip"></div>
<header>
  <div class="topbar">
  <h1>Dashboard BN — Team Fit (AT / AC / AE)</h1>

  <div class="row top-controls">
    <div>
      
      <select id="projectSel"></select>
    </div>
    <div>
      
      <select id="teamSel"></select>
    </div>
  </div>
</div>

  <div class="kpis">
          <div class="kpi">
            <div class="t">AE (média)</div>
            <div class="v" id="kpiAE">—</div>
            <div class="s" id="kpiAETier">—</div>
          </div>
          <div class="kpi">
            <div class="t">AT (contínuo)</div>
            <div class="v" id="kpiAT">—</div>
            <div class="s" id="kpiATTier">—</div>
          </div>
          <div class="kpi">
            <div class="t">AC (contínuo)</div>
            <div class="v" id="kpiAC">—</div>
            <div class="s" id="kpiACTier">—</div>
          </div>
  </div>
    <!-- STRIP FIXO (Projeto) -->
  <div id="projectStrip" class="projectStrip" style="display:none">
    <div class="stripCard" style="flex:1.05">
      <div class="stripTitle">
        <span><b>Cobertura técnica</b> (M/S/C) + redundância</span>
        <span class="mini" id="covTeamLabel"></span>
      </div>
      <div id="covBars" class="covRows"></div>
    </div>

    <div class="stripCard" style="flex:1.6">
      <div class="stripTitle">
        <span><b>Ranking</b> por equipe (Expert × BN)</span>
        <span class="mini" id="rankMeta"></span>
      </div>
      <div id="rankBoard" class="rankBoard"></div>
    </div>
  </div>

</header>

<div class="wrap">
  <div class="grid">
    <!-- LEFT -->
    <section class="card">
      <div class="hd">
        <strong>1) Dados (importar / atualizar)</strong>
        <div class="row">
          <label class="file btn">
            <input id="fileInput" type="file" accept=".csv,.tsv,.txt" />
            Importar arquivo
          </label>
          <button id="btnSample" class="btn">Carregar exemplo</button>
          <button id="btnClear" class="btn">Limpar</button>
          <label class="file btn">
            <input id="fileDetails" type="file" accept=".csv,.tsv,.txt" />
            Importar detalhes
          </label>
        </div>
      </div>
      <div class="bd">
        <div id="msg" class="note" style="display:none"></div>
        <div id="detailsBox" class="detailsBox" style="display:none"></div>

        <div id="err" class="err" style="display:none"></div>

        

        <div style="height:10px"></div>

        

        
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card">
      <div class="hd">
        <strong>2) Rede (estrutura + pesos/funções)</strong>
        <div class="pill">AT: <span class="mono">WMAX</span> (Dom=1, Eco=1, Ling=3)</div>
        <div class="pill">AC: <span class="mono">WMAX</span> (PC_VL=1, PC_L=2, PC_M=5, PC_H=1, PC_VH=5)</div>
        <div class="pill">AE: <span class="mono">WMIN</span> (AT=3, AC=1)</div>
      </div>
      <div class="bd">
        <div class="split">
          <div class="barwrap">
            <div class="barcard">
              <div class="ttl">
                <strong>Estrutura visual (estilo BN)</strong>
                <span class="mini">muda ao trocar a equipe</span>
              </div>
              <div class="svgbox">
                <div id="bnGraphWrap">
                  <svg id="bnGraph"
                      width="1200" height="580"
                      viewBox="0 0 1850 680"
                      preserveAspectRatio="xMinYMin meet"
                      aria-label="Rede Bayesiana (com gráficos por nó)">
                  </svg>
                </div>
              <div style="height:12px"></div>

              <div class="barcard">
                <div class="ttl">
                  <strong>Comparativo do projeto — distribuição por equipe (VL..VH)</strong>
                  
                </div>

                <div class="grid2" style="margin-top:10px">
                  <div class="barcard">
                    <div class="ttl"><strong>AT</strong><span class="mini" id="projMetaAT">AT (aprox. ou dist_AT)</span></div>
                    <svg id="projAT" width="100%" height="260" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                    <div class="ttl"><strong>AC</strong><span class="mini" id="projMetaAC">AC (aprox. ou dist_AC)</span></div>
                    <svg id="projAC" width="100%" height="260" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                    <div class="ttl"><strong>AE</strong><span class="mini" id="projMetaAE">AE (dist_AE)</span></div>
                    <svg id="projAE" width="100%" height="260" viewBox="0 0 760 260"></svg>
                  </div>
                  <div class="barcard">
                    <div class="ttl"><strong>Dom / Eco / Ling / PC</strong><span class="mini" id="projMetaTech">Dom/Eco/Ling/PC</span></div>
                    <svg id="projTech" width="100%" height="340" viewBox="0 0 760 340"></svg>
                  </div>
                </div>

                <div class="foot">
                  Dica: para mostrar Dom/Eco/Ling com distribuições reais por equipe, adicione no CSV as colunas
                  <span class="mono">dist_Dom</span>, <span class="mono">dist_Eco</span>, <span class="mono">dist_Ling</span>.
                  Para PC, use <span class="mono">dist_PC</span> (5 valores) ou colunas <span class="mono">PC_VL..PC_VH</span>.
                </div>
              </div>

              </div>

              <div class="legend">
                <div class="leg"><span class="sw" style="background:#7aa2ff"></span>Equipe selecionada</div>
                <div class="leg"><span class="sw" style="background:#62d26f"></span>Referência / centroides</div>
              </div>

              
              <div style="height:10px"></div>

              

            </div>
          </div>
        </div>

        <div style="height:12px"></div>

       

        

        <div class="barcard">
          <div class="ttl">
            <strong>3) Tabela de evidências e resultado (linha do CSV)</strong>
            <span class="mini">mostra exatamente o que entrou/saíu</span>
          </div>
          <div style="overflow:auto">
            <table id="rowTable"></table>
          </div>
          <div class="foot">
            Dica: se você quiser incluir Dom/Eco/Ling discretizados (VL..VH) e PC_VL..PC_VH, basta adicionar colunas no CSV.
            O dashboard já está pronto para plugar esses valores nos rótulos do grafo (lado esquerdo).
          </div>
        </div>

      </div>
    </section>
  </div>
</div>

<script>
/* =======================
   Config (você pode editar)
   ======================= */
const CENTROIDS = [
  {tier:"VL", v:0.1}, {tier:"L", v:0.3}, {tier:"M", v:0.5}, {tier:"H", v:0.7}, {tier:"VH", v:0.9}
];

const DEFAULT_MODEL = {
  AT: { func: "WMAX", weights: { Dom: 1, Eco: 1, Ling: 3 } },
  AC: { func: "WMAX", weights: { PC_VL: 1, PC_L: 2, PC_M: 5, PC_H: 1, PC_VH: 5 } },
  AE: { func: "WMIN", weights: { AT: 3, AC: 1 } }
};

/* Tooltips (aparecem ao passar o mouse nos nós AT/AC/AE) */
const TOOLTIP_TEMPLATES = {
  TT_AT: () => ({
    title: "AT — Technological Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AT.func}`,
      `Pesos: Dom=${DEFAULT_MODEL.AT.weights.Dom}, Eco=${DEFAULT_MODEL.AT.weights.Eco}, Ling=${DEFAULT_MODEL.AT.weights.Ling}`,
      "Fórmula:",
      `S = Σ x_j`,
      `e_i = (w_i·x_i + (S − x_i)) / (w_i + (n − 1))`,
      `WMAX = max_i e_i`
    ],
    note: "Aqui, x_i é o score (0–1) de Dom/Eco/Ling. Se x_i vier como vetor (amostras), o max é posição a posição."
  }),
  TT_AC: () => ({
    title: "AC — Collaboration Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AC.func}`,
      `Pesos: PC_VL=${DEFAULT_MODEL.AC.weights.PC_VL}, PC_L=${DEFAULT_MODEL.AC.weights.PC_L}, PC_M=${DEFAULT_MODEL.AC.weights.PC_M}, PC_H=${DEFAULT_MODEL.AC.weights.PC_H}, PC_VH=${DEFAULT_MODEL.AC.weights.PC_VH}`,
      "Fórmula:",
      `S = Σ x_j`,
      `e_i = (w_i·x_i + (S − x_i)) / (w_i + (n − 1))`,
      `WMAX = max_i e_i`
    ],
    note: "Aqui, x_i vem da evidência de colaboração (ex.: PC_VL..PC_VH, ou depois sua transformação para valor 0–1)."
  }),
  TT_AE: () => ({
    title: "AE — Team Fit",
    lines: [
      `Função: ${DEFAULT_MODEL.AE.func}`,
      `Pesos: AT=${DEFAULT_MODEL.AE.weights.AT}, AC=${DEFAULT_MODEL.AE.weights.AC}`,
      "Fórmula:",
      `S = Σ x_j`,
      `e_i = (w_i·x_i + (S − x_i)) / (w_i + (n − 1))`,
      `WMIN = min_i e_i`
    ],
    note: "Aqui, x_i são os valores contínuos de AT e AC (0–1)."
  })
};

function tooltipHtml(t){
  const esc = (s)=>String(s)
    .replaceAll("&","&amp;").replaceAll("<","&lt;")
    .replaceAll(">","&gt;").replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
  const lines = (t.lines||[]).map(l=>{
    // linhas de fórmula e pesos em monoespaçado
    if (l.includes("=") || l.includes("WMAX") || l.includes("WMIN") || l.includes("e_i") || l.includes("Σ") || l.includes("·") || l.includes("−")){
      return `<div class="tt-mono">${esc(l)}</div>`;
    }
    return `<div>${esc(l)}</div>`;
  }).join("");
  return `<div class="tt-title">${esc(t.title||"")}</div>${lines}${t.note?`<div class="tt-muted">${esc(t.note)}</div>`:""}`;
}


function attachNodeTooltips(){
  const tip = $("tooltip");
  if (!tip) return;

  function bind(el){
    el.addEventListener("mouseenter", ()=>{
      const id = el.getAttribute("data-tooltip-id");
      const builder = TOOLTIP_TEMPLATES[id];
      if (!builder) return;
      tip.innerHTML = tooltipHtml(builder());
      tip.style.display = "block";
    });
    el.addEventListener("mousemove", (ev)=>{
      const pad = 14;
      const w = tip.offsetWidth || 380;
      const h = tip.offsetHeight || 120;
      let x = ev.clientX + pad;
      let y = ev.clientY + pad;
      const maxX = window.innerWidth - w - 8;
      const maxY = window.innerHeight - h - 8;
      x = Math.min(x, maxX);
      y = Math.min(y, maxY);
      tip.style.left = x + "px";
      tip.style.top = y + "px";
    });
    el.addEventListener("mouseleave", ()=>{
      tip.style.display = "none";
    });
  }

  const els = document.querySelectorAll("[data-tooltip-id]");
  els.forEach(bind);
}



// Paleta simples (para quando você quiser comparar várias equipes no mesmo gráfico)
const COLORS = ["#7aa2ff", "#62d26f", "#ffd166", "#ff6b6b", "#c77dff", "#4dd4ff"];

/* =======================
   Util
   ======================= */
function $(id){ return document.getElementById(id); }

function setText(id, value){
  const el = $(id);
  if (!el) return;
  el.textContent = value;
}
function setHTML(id, html){
  const el = $(id);
  if (!el) return;
  el.innerHTML = html;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmt(x, d=3){
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  const n = Number(x);
  if (!Number.isFinite(n)) return String(x);
  return n.toFixed(d);
}
function nearestTier(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return {tier:"—", centroid:null, dist:null};
  let best = null;
  for (const c of CENTROIDS){
    const dist = Math.abs(n - c.v);
    if (!best || dist < best.dist) best = {tier:c.tier, centroid:c.v, dist};
  }
  return best;
}
function oneHotDistFromTier(tier){
  const order = ["VL","L","M","H","VH"];
  const idx = order.indexOf(tier);
  if (idx < 0) return [0.2,0.2,0.2,0.2,0.2];
  const out = [0,0,0,0,0];
  out[idx] = 1;
  return out;
}
function scalarTo5StateDist(v){
  const t = nearestTier(v);
  return oneHotDistFromTier(t.tier);
}

function safeParseFloat(s){
  if (s === null || s === undefined) return NaN;
  if (typeof s === "number") return s;
  const t = String(s).trim().replace(",", "."); // aceita decimal com vírgula
  const n = Number(t);
  return Number.isFinite(n) ? n : NaN;
}

/* =======================
   CSV/TSV parsing (robusto p/ TAB e aspas)
   ======================= */
function detectDelimiter(headerLine){
  const tabs  = (headerLine.match(/\t/g) || []).length;
  const commas = (headerLine.match(/,/g) || []).length;
  const semis  = (headerLine.match(/;/g) || []).length;

  // prioridade: o que tiver mais separadores no cabeçalho
  if (tabs >= commas && tabs >= semis) return "\t";
  if (semis > commas) return ";";
  return ",";
}


function splitLine(line, delim){
  // split respeitando aspas
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0; i<line.length; i++){
    const ch = line[i];
    if (ch === '"'){
      // dupla aspas -> escape
      if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    } else if (ch === delim && !inQ){
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map(s => s.trim());
}
function joinQuotedLines(text){
  const raw = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

  const lines = [];
  let cur = "";
  let inQ = false;

  function countQuoteToggles(line){
    let toggles = 0;
    for (let i=0; i<line.length; i++){
      if (line[i] === '"'){
        // aspas escapada ("")
        if (i+1 < line.length && line[i+1] === '"'){ i++; continue; }
        toggles++;
      }
    }
    return toggles;
  }

  for (const line of raw){
    cur = cur ? (cur + "\n" + line) : line;

    if (countQuoteToggles(line) % 2 === 1){
      inQ = !inQ;
    }

    if (!inQ){
      if (cur.trim().length > 0) lines.push(cur);
      cur = "";
    }
  }

  if (cur.trim().length > 0) lines.push(cur);
  return lines;
}


function parseTextToRows(text){
  // normaliza quebras
  const lines = joinQuotedLines(text);
  if (!lines.length) return {cols:[], rows:[]};

  const delim = detectDelimiter(lines[0]);
  const cols = splitLine(lines[0], delim);

  const rows = [];
  for (let i=1; i<lines.length; i++){
    const parts = splitLine(lines[i], delim);

    // caso: CSV com dist_AE quebrado em várias colunas
    // esperadas 8 colunas; se tiver > 8, junta o resto em dist_AE
    if (parts.length > cols.length){
      const fixed = parts.slice(0, cols.length-1);
      const tail = parts.slice(cols.length-1).join(delim); // junta de volta
      parts.length = 0;
      parts.push(...fixed, tail);
    }

    const obj = {};
    for (let c=0; c<cols.length; c++){
      obj[cols[c]] = (parts[c] ?? "").trim();
    }
    rows.push(obj);
  }
  return {cols, rows};
}

function parseDistAE(v){
  // aceita "0.1,0.2,0.3,0.4,0.0" ou "[...]" etc.
  const raw = String(v ?? "").trim().replace(/^\[|\]$/g,"");
  const parts = raw.split(",").map(s => safeParseFloat(s.trim())).filter(n => Number.isFinite(n));
  // se vier mais que 5 (ex.: por erro), corta; se vier menos, completa
  const arr = parts.slice(0,5);
  while (arr.length < 5) arr.push(0);
  // normaliza se soma não for 1 (só p/ visual)
  const sum = arr.reduce((a,b)=>a+b,0);
  if (sum > 0.000001){
    return arr.map(x => x/sum);
  }
  return arr;
}

/* =======================
   Estado do app
   ======================= */
let DATA = [];        // linhas
let COLUMNS = [];     // colunas
let IDX = {projects:[], teamsByProject:new Map()};

function setMessage(kind, text){
  const msg = $("msg");
  const err = $("err");
  msg.style.display = "none"; err.style.display = "none";
  if (!text) return;
  if (kind === "err"){ err.textContent = text; err.style.display="block"; }
  else { msg.textContent = text; msg.style.display="block"; }
}

function buildIndex(){
  const projects = Array.from(new Set(DATA.map(r => r.projeto_id || r.project_id || r.project || "—"))).sort();
  const teamsByProject = new Map();
  for (const p of projects){
    const teams = DATA.filter(r => (r.projeto_id||r.project_id||r.project||"—") === p)
                      .map(r => r.team_id || r.team || r.teamId || "—");
    teamsByProject.set(p, Array.from(new Set(teams)).sort());
  }
  IDX = {projects, teamsByProject};
}

function pickFirst(){
  const p = IDX.projects[0] ?? "";
  const t = (IDX.teamsByProject.get(p) || [])[0] ?? "";
  return {p, t};
}

/* =======================
   Render helpers (SVG)
   ======================= */
function svgClear(svg){
  if (!svg) return;
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
function svgEl(name, attrs={}){
  const el = document.createElementNS("http://www.w3.org/2000/svg", name);
  for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function drawBars(svg, probs, color="#7aa2ff"){
  if(!svg) return;
  svgClear(svg);
  const W = 520, H = 160;
  const padL=50, padR=20, padT=16, padB=30;
  const innerW = W-padL-padR, innerH = H-padT-padB;

  // axes
  svg.appendChild(svgEl("line",{x1:padL,y1:padT+innerH,x2:padL+innerW,y2:padT+innerH,stroke:"#2a3b55","stroke-width":"2"}));
  svg.appendChild(svgEl("line",{x1:padL,y1:padT,x2:padL,y2:padT+innerH,stroke:"#2a3b55","stroke-width":"2"}));

  const labels = ["VL","L","M","H","VH"];
  const max = Math.max(...probs, 0.01);
  const bw = innerW/labels.length * 0.65;
  const gap = innerW/labels.length;

  for (let i=0;i<labels.length;i++){
    const x = padL + i*gap + (gap-bw)/2;
    const h = (probs[i]/max) * innerH;
    const y = padT + innerH - h;

    svg.appendChild(svgEl("rect",{x:x,y:y,width:bw,height:h,rx:"8",ry:"8",fill:color,opacity:"0.85"}));

    // value label
    const txt = svgEl("text",{x:x+bw/2,y:y-6,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = (probs[i]*100).toFixed(1)+"%";
    svg.appendChild(txt);

    // tier label
    const lab = svgEl("text",{x:x+bw/2,y:padT+innerH+20,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = labels[i];
    svg.appendChild(lab);
  }

  // y ticks (0 e 100% do max)
  const t0 = svgEl("text",{x:padL-10,y:padT+innerH+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  t0.textContent = "0";
  svg.appendChild(t0);
  const t1 = svgEl("text",{x:padL-10,y:padT+10,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  t1.textContent = (max*100).toFixed(0)+"%";
  svg.appendChild(t1);
}


function distFromTier(tier){
  const map = {VL:0, L:1, M:2, H:3, VH:4, "Very Low":0, "Low":1, "Medium":2, "High":3, "Very High":4};
  const k = map[String(tier||"").trim()] ;
  const a = [0,0,0,0,0];
  if (k === 0 || k === 1 || k === 2 || k === 3 || k === 4) a[k] = 1;
  return a;
}

function distFromCont(x){
  // aproxima distribuição pelo valor contínuo: quanto mais perto do centroide, maior o peso
  const n = safeParseFloat(x);
  if (!Number.isFinite(n)) return [0,0,0,0,0];
  const raw = CENTROIDS.map(c => Math.max(0, 1 - (Math.abs(n - c.v) / 0.40))); // 0.40 = largura simples
  const sum = raw.reduce((a,b)=>a+b,0);
  if (sum < 1e-9) return distFromTier(nearestTier(n).tier);
  return raw.map(v => v/sum);
}

function drawMiniBars(svg, probs, color="#7aa2ff"){
  svgClear(svg);
  const W = 520, H = 120;
  const padL=10, padR=10, padT=10, padB=26;
  const innerW = W-padL-padR, innerH = H-padT-padB;

  const labels = ["VL","L","M","H","VH"];
  const max = Math.max(...probs, 0.01);
  const bw = innerW/labels.length * 0.68;
  const gap = innerW/labels.length;

  for (let i=0;i<labels.length;i++){
    const x = padL + i*gap + (gap-bw)/2;
    const h = (probs[i]/max) * innerH;
    const y = padT + innerH - h;

    svg.appendChild(svgEl("rect",{x:x,y:y,width:bw,height:h,rx:"8",ry:"8",fill:color,opacity:"0.85"}));

    const txt = svgEl("text",{x:x+bw/2,y:y-6,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = (probs[i]*100).toFixed(1)+"%";
    svg.appendChild(txt);

    const lab = svgEl("text",{x:x+bw/2,y:padT+innerH+18,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = labels[i];
    svg.appendChild(lab);
  }
}


function drawNodeWithBars(svg, {x,y,w,h,title,dist, funcLabel=null, weightsLabel="", metaLabel="", tooltipId=null, barLabels=null, barWidthRatio=0.68, maxValue=null}){

  const g = svgEl("g",{});
  g.appendChild(svgEl("rect",{x,y,width:w,height:h,rx:"18",ry:"18",fill:"#ffffff",stroke:"#d7dde6"}));

  const t = svgEl("text",{x:x+w/2,y:y+26,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-weight":"800","font-family":"ui-sans-serif"});
  t.textContent = title;
  g.appendChild(t);

  if (metaLabel){
    const meta = svgEl("text",{x:x+w-12,y:y+26,"text-anchor":"end",fill:"#6b7280","font-size":"20","font-family":"ui-monospace"});
    meta.textContent = metaLabel;
    g.appendChild(meta);
  }

  if (funcLabel){
    const fx = x + 14;
    const fy = y + 48;
    const f = svgEl("text",{x:fx,y:fy,fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    f.textContent = funcLabel;
    if (tooltipId){
      f.setAttribute("data-tooltip-id", tooltipId);
      f.setAttribute("class", "formulaTag");
    }
    g.appendChild(f);

    const wtxt = svgEl("text",{x:fx + 58,y:fy,fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    wtxt.textContent = weightsLabel || "";
    g.appendChild(wtxt);
  }

  const pad = 14;
  const barTop = y + 60;
  const barH = h - 60 - 28;
  const barY0 = barTop + barH;
  const labels = barLabels || ["VL","L","M","H","VH"];

    // ====== BARRAS HORIZONTAIS (substitui as colunas verticais) ======
  const max = (Number.isFinite(maxValue) && maxValue > 0)
    ? maxValue
    : Math.max(...dist, 0.001);

  // espaço para o rótulo (VL..VH) na esquerda e % na direita
  const labelCol = Math.min(110, Math.max(...labels.map(s => String(s).length)) * 7 + 18);
  const pctCol   = 46; // espaço para "100%"
  const barX0    = x + pad + labelCol;
  const barWmax  = Math.max(10, w - (barX0 - x) - pad - pctCol);

  const rowGap = barH / labels.length;
  const bh = Math.max(10, rowGap * 0.60);

  for (let i=0;i<labels.length;i++){
    const by = barTop + i*rowGap + (rowGap - bh)/2;
    const bw = (dist[i]/max) * barWmax;

    // rótulo (VL..VH) à esquerda
    const l = svgEl("text",{
      x: barX0 - 8,
      y: by + bh*0.72,
      "text-anchor":"end",
      fill:"#4b5563",
      "font-size":"20",
      "font-family":"ui-monospace"
    });
    l.textContent = labels[i];
    g.appendChild(l);

    // barra horizontal
    g.appendChild(svgEl("rect",{
      x: barX0,
      y: by,
      width: bw,
      height: bh,
      rx:"8", ry:"8",
      fill:"#8fb0ff",
      opacity:"0.95"
    }));

    // percentual à direita da barra
    const p = svgEl("text",{
      x: barX0 + bw + 8,
      y: by + bh*0.72,
      "text-anchor":"start",
      fill:"#0b1220",
      "font-size":"20",
      "font-family":"ui-monospace"
    });
    p.textContent = (dist[i]*100).toFixed(0) + "%";
    g.appendChild(p);
  }


  svg.appendChild(g);
  return {x,y,w,h};
}


function drawArrow(svg, x1,y1,x2,y2){
  svg.appendChild(svgEl("line",{
    x1,y1,x2,y2,
    stroke:"#6b7280",
    "stroke-width":"2.2",
    "marker-end":"url(#arrow)"
  }));
}


function renderBNGraph(row, dists){
  const svg = $("bnGraph");
  if (!svg) return;
  svgClear(svg);

  const defs = svgEl("defs",{});
  const marker = svgEl("marker",{id:"arrow",viewBox:"0 0 10 10",refX:"9",refY:"5",markerWidth:"8",markerHeight:"8",orient:"auto-start-reverse"});
  marker.appendChild(svgEl("path",{d:"M 0 0 L 10 5 L 0 10 z", fill:"#6b7280"}));
  defs.appendChild(marker);
  svg.appendChild(defs);


  //mudar tamanho das caixas dos graficos
  const smallW = 380, smallH = 180;
  const boxW = 420, boxH = 240;
  const boxW_AT = 600


  const dom = drawNodeWithBars(svg,{x:50,y:40,w:smallW,h:smallH,title:"Domínio (Dom)",dist:dists.dom, metaLabel:dists.metaDom});
  const eco = drawNodeWithBars(svg,{x:50,y:190,w:smallW,h:smallH,title:"Ecossistema (Eco)",dist:dists.eco, metaLabel:dists.metaEco});
  const ling= drawNodeWithBars(svg,{x:50,y:340,w:smallW,h:smallH,title:"Linguagens (Ling)",dist:dists.ling, metaLabel:dists.metaLing});
  // PC evidence as five nodes: PC_VL..PC_VH (each mapped to VL..VH states)
  
  const pcTitles = ["PC_VL","PC_L","PC_M","PC_H","PC_VH"];
  const shares = (dists.pc || [0,0,0,0,0]).map(x=>Number(x));
  const pcNodes = [];

  const pcX = dom.x;                 // alinha na mesma coluna de Dom/Eco/Ling
  const pcY0 = ling.y + ling.h + 26; // começa logo abaixo de Linguagens
  const pcW = dom.w;                 // mesma largura das caixas da esquerda
  const pcH = 50, pcGap = 10;


  for (let i=0;i<5;i++){
    const s = Number.isFinite(shares[i]) ? shares[i] : 0;
    pcNodes.push(drawNodeWithBars(svg,{
      x: pcX,
      y: pcY0 + i*(pcH+pcGap),
      w: pcW,
      h: pcH,
      title: pcTitles[i],
      dist: [Math.max(0, Math.min(1, s))],
      barLabels: [""],//["% pares"],
      maxValue: 1,     // distribuição VL..VH do PC_*
      metaLabel: (s*100).toFixed(0)+"%" // mostra o share como “46%”
    }));
  }

 
  


  const at  = drawNodeWithBars(svg,{x:650,y:170,w:boxW,h:boxH,title:"AT (Technological Fit)",dist:dists.at,
    funcLabel: DEFAULT_MODEL.AT.func,
    weightsLabel:`(Dom=${DEFAULT_MODEL.AT.weights.Dom}, Eco=${DEFAULT_MODEL.AT.weights.Eco}, Ling=${DEFAULT_MODEL.AT.weights.Ling})`,
    tooltipId: "TT_AT"// DEFAULT_MODEL.AT.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  const ac  = drawNodeWithBars(svg,{x:650,y:500,w:boxW,h:boxH,title:"AC (Collaboration Fit)",dist:dists.ac,
    funcLabel: DEFAULT_MODEL.AC.func,
    weightsLabel:`(PC_VL=${DEFAULT_MODEL.AC.weights.PC_VL}, PC_L=${DEFAULT_MODEL.AC.weights.PC_L}, PC_M=${DEFAULT_MODEL.AC.weights.PC_M}, PC_H=${DEFAULT_MODEL.AC.weights.PC_H}, PC_VH=${DEFAULT_MODEL.AC.weights.PC_VH})`,
    tooltipId: "TT_AC" //DEFAULT_MODEL.AC.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  const ae  = drawNodeWithBars(svg,{x:1180,y:400,w:boxW,h:boxH,title:"AE (Team Fit)",dist:dists.ae,
    funcLabel: DEFAULT_MODEL.AE.func,
    weightsLabel:`(AT=${DEFAULT_MODEL.AE.weights.AT}, AC=${DEFAULT_MODEL.AE.weights.AC})`,
    tooltipId:"TT_AE" // DEFAULT_MODEL.AE.func === "WMAX" ? "TT_WMAX" : "TT_WMIN"
  });

  drawArrow(svg, dom.x+dom.w, dom.y+dom.h/2, at.x, at.y+50);
  drawArrow(svg, eco.x+eco.w, eco.y+eco.h/2, at.x, at.y+boxH/2);
  drawArrow(svg, ling.x+ling.w, ling.y+ling.h/2, at.x, at.y+boxH-50);

  const acY0 = ac.y + 50;
  const acYstep = (boxH - 100) / 4;

  pcNodes.forEach((n, i) => {
    drawArrow(svg, n.x + n.w, n.y + n.h/2, ac.x, acY0 + i * acYstep);
  });


  drawArrow(svg, at.x+at.w, at.y+boxH/2, ae.x, ae.y+boxH/2 - 24);
  drawArrow(svg, ac.x+ac.w, ac.y+boxH/2, ae.x, ae.y+boxH/2 + 24);

  // re-bind tooltips for new SVG text nodes
  attachNodeTooltips();
}

function drawAxis(svg, atVal, acVal, color="#7aa2ff"){
  if(!svg) return;
  svgClear(svg);
  const W=520, H=140;
  const padL=50,padR=20,padT=22,padB=28;
  const innerW=W-padL-padR, innerH=H-padT-padB;

  // baseline
  const yAT = padT + innerH*0.35;
  const yAC = padT + innerH*0.75;

  const baseStyle = {stroke:"#2a3b55","stroke-width":"8","stroke-linecap":"round"};
  svg.appendChild(svgEl("line",{x1:padL,y1:yAT,x2:padL+innerW,y2:yAT,...baseStyle}));
  svg.appendChild(svgEl("line",{x1:padL,y1:yAC,x2:padL+innerW,y2:yAC,...baseStyle}));

  // centroid marks
  for (const c of CENTROIDS){
    const x = padL + c.v * innerW;
    for (const y of [yAT,yAC]){
      svg.appendChild(svgEl("line",{x1:x,y1:y-10,x2:x,y2:y+10,stroke:"#62d26f","stroke-width":"2",opacity:"0.9"}));
    }
    const lab = svgEl("text",{x:x,y:padT+innerH+20,"text-anchor":"middle",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = c.tier;
    svg.appendChild(lab);
  }

  function drawPoint(val, y, label){
    const v = clamp(Number(val), 0, 1);
    const x = padL + v*innerW;

    // glow
    svg.appendChild(svgEl("circle",{cx:x,cy:y,r:"10",fill:color,opacity:"0.22"}));
    svg.appendChild(svgEl("circle",{cx:x,cy:y,r:"6",fill:color,opacity:"0.92"}));

    const t = nearestTier(v);
    const txt = svgEl("text",{x:x,y:y-14,"text-anchor":"middle",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
    txt.textContent = `${label}: ${fmt(v,3)} (${t.tier})`;
    svg.appendChild(txt);
  }

  // labels
  const l1 = svgEl("text",{x:padL-12,y:yAT+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  l1.textContent="AT";
  svg.appendChild(l1);

  const l2 = svgEl("text",{x:padL-12,y:yAC+4,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
  l2.textContent="AC";
  svg.appendChild(l2);

  drawPoint(atVal, yAT, "AT");
  drawPoint(acVal, yAC, "AC");
}

/* =======================
   UI: selects + render
   ======================= */
function fillSelect(sel, values){
  sel.innerHTML = "";
  for (const v of values){
    const opt = document.createElement("option");
    opt.value = v; opt.textContent = v;
    sel.appendChild(opt);
  }
}

function currentRow(){
  const p = $("projectSel").value;
  const t = $("teamSel").value;
  // pega a primeira linha que bate (se você tiver várias avaliações por equipe, pode mudar aqui)
  return DATA.find(r => (r.projeto_id||r.project_id||r.project||"—") === p &&
                        (r.team_id||r.team||r.teamId||"—") === t) || null;
}

function renderRowTable(row){
  const table = $("rowTable");
  if (!row){
    table.innerHTML = "<tr><td style='color:#9fb0c0'>— sem dados —</td></tr>";
    return;
  }
  const cols = COLUMNS.length ? COLUMNS : Object.keys(row);
  let html = "<thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>";
  for (const c of cols){
    const v = row[c] ?? "";
    const vv = (String(v).length>0) ? String(v) : "—";
    html += `<tr><td><code>${escapeHtml(c)}</code></td><td>${escapeHtml(vv)}</td></tr>`;
  }
  html += "</tbody>";
  table.innerHTML = html;
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function safeInt(x){
  const n = parseInt(String(x ?? "").trim(), 10);
  return Number.isFinite(n) ? n : 0;
}
function normalizeList(v){
  const s = String(v ?? "").trim();
  if (!s) return [];
  return s.split(",").map(x=>x.trim()).filter(Boolean);
}
function uniq(arr){ return Array.from(new Set(arr)); }

function teamKey(row){
  return row.team_id ?? row.team ?? row.teamId ?? "—";
}
function shortDevs(teamStr){
  const s = String(teamStr ?? "").replace(/[\[\]]/g,"").trim();
  if (!s) return "";
  const parts = s.split(/[;,\s]+/).map(x=>x.trim()).filter(Boolean);
  if (!parts.length) return "";
  const shown = parts.slice(0,3).join(" · ");
  return parts.length>3 ? `${shown} · …` : shown;
}

function renderCoveragePanel(row, label=""){
  const wrap = $("covBars");
  const lbl  = $("covTeamLabel");
  if (!wrap || !lbl) return;

  if (!row){
    wrap.innerHTML = "";
    lbl.textContent = "";
    return;
  }

  lbl.textContent = label ? `Equipe: ${label}` : "";

  const dims = [
    {k:"dominio",     label:"DOM"},
    {k:"ecossistema", label:"ECO"},
    {k:"linguagens",  label:"LING"}
  ];

  function covLine(prefix, kind){
    const total   = safeInt(row[`${prefix}_${kind}_total`]);
    const covered = safeInt(row[`${prefix}_${kind}_covered`]);
    const pct     = total>0 ? Math.round((covered/total)*100) : 0;
    return {total, covered, pct};
  }

  function topAndRedund(prefix){
    const all = uniq([
      ...normalizeList(row[`${prefix}_m_covered_list`]),
      ...normalizeList(row[`${prefix}_s_covered_list`]),
      ...normalizeList(row[`${prefix}_c_covered_list`]),
    ]);

    const redund = uniq([
      ...normalizeList(row[`${prefix}_m_covered_list`]).slice(safeInt(row[`${prefix}_m_total`])),
      ...normalizeList(row[`${prefix}_s_covered_list`]).slice(safeInt(row[`${prefix}_s_total`])),
      ...normalizeList(row[`${prefix}_c_covered_list`]).slice(safeInt(row[`${prefix}_c_total`])),
    ]);

    return {
      top: all.slice(0,2),
      redund: redund.slice(0,2),
      extraTop: Math.max(0, all.length-2),
      extraRed: Math.max(0, redund.length-2)
    };
  }

  function line(kind, obj){
    return `
      <div class="hbarLine" data-kind="${kind}">
        <div class="mini">${kind}</div>
        <div class="hbar"><span style="width:${obj.pct}%"></span></div>
        <div class="hbarMeta">${obj.total>0 ? `${obj.covered}/${obj.total}` : "—"}</div>
      </div>
    `;
  }

  wrap.innerHTML = dims.map(d=>{
    const M = covLine(d.k,"m");
    const S = covLine(d.k,"s");
    const C = covLine(d.k,"c");
    const t = topAndRedund(d.k);

    const topTxt = t.top.length ? `${t.top.join(", ")}${t.extraTop?` (+${t.extraTop})`:""}` : "—";
    const redTxt = t.redund.length ? `${t.redund.join(", ")}${t.extraRed?` (+${t.extraRed})`:""}` : "—";

    return `
      <div class="covRow">
        <div class="dim">${d.label}</div>
        <div class="covStack">
          ${line("M", M)}
          ${line("S", S)}
          ${line("C", C)}
          <div class="techHint"><b>Coberto:</b> ${escapeHtml(topTxt)} &nbsp; • &nbsp; <b>Redund.:</b> ${escapeHtml(redTxt)}</div>
        </div>
      </div>
    `;
  }).join("");
}

function renderProjectRankBoard(projectId, selectedRow){
  const strip = $("projectStrip");
  const board = $("rankBoard");
  const meta  = $("rankMeta");
  if (!strip || !board || !meta) return;

  if (!DATA || !DATA.length || !projectId){
    strip.style.display = "none";
    return;
  }

  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||r.project||"")===String(projectId));
  if (!rows.length){
    strip.style.display = "none";
    return;
  }

  const selTeam = selectedRow ? teamKey(selectedRow) : "";

  const maxRank = Math.max(
    ...rows.map(r=>safeParseFloat(r.rank_expert)).filter(Number.isFinite),
    ...rows.map(r=>safeParseFloat(r.rank_bn)).filter(Number.isFinite),
    rows.length
  ) || rows.length || 5;

  const ordered = rows.slice().sort((a,b)=>{
    const ra = safeParseFloat(a.rank_bn), rb = safeParseFloat(b.rank_bn);
    if (Number.isFinite(ra) && Number.isFinite(rb)) return ra-rb;

    const ea = safeParseFloat(a.rank_expert), eb = safeParseFloat(b.rank_expert);
    if (Number.isFinite(ea) && Number.isFinite(eb)) return ea-eb;

    return teamKey(a).localeCompare(teamKey(b));
  });

  meta.textContent = `${rows.length} equipes`;

  board.innerHTML = ordered.map(r=>{
    const t = teamKey(r);
    const devs = shortDevs(r.team_str);

    const re = safeParseFloat(r.rank_expert);
    const rb = safeParseFloat(r.rank_bn);

    const he = Number.isFinite(re) ? Math.round(((maxRank - re + 1)/maxRank)*100) : 0;
    const hb = Number.isFinite(rb) ? Math.round(((maxRank - rb + 1)/maxRank)*100) : 0;

    const active = (t===selTeam) ? "active" : "";

    return `
      <div class="teamCol ${active}" data-team="${escapeHtml(t)}">
        <div class="teamName" title="${escapeHtml(t)}">${escapeHtml(t)}</div>
        <div class="teamDevs" title="${escapeHtml(devs)}">${escapeHtml(devs || "—")}</div>

        <div class="vbars">
          <div class="vbarBox" title="Ranking do expert (1 = melhor)">
            <div class="vbar expert" style="height:${he}%"></div>
            <div class="vnum">${escapeHtml(Number.isFinite(re) ? String(re) : "—")}</div>
          </div>
          <div class="vbarBox" title="Ranking da BN (1 = melhor)">
            <div class="vbar" style="height:${hb}%"></div>
            <div class="vnum">${escapeHtml(Number.isFinite(rb) ? String(rb) : "—")}</div>
          </div>
        </div>

        <div class="vlab"><span>EXPERT</span><span>BN</span></div>
      </div>
    `;
  }).join("");

  // Hover mostra a cobertura dessa equipe (sem perder o filtro)
  // Click seleciona a equipe no select e atualiza o dashboard inteiro
  const cols = board.querySelectorAll(".teamCol");
  cols.forEach(col=>{
    const teamId = col.getAttribute("data-team");
    const r = ordered.find(x=>String(teamKey(x))===String(teamId));
    if (!r) return;

    col.addEventListener("mouseenter", ()=> renderCoveragePanel(r, teamId));
    col.addEventListener("mouseleave", ()=> renderCoveragePanel(selectedRow, selTeam));
    col.addEventListener("click", ()=>{
      const sel = $("teamSel");
      if (sel){
        sel.value = teamId;
        render();
      }
    });
  });

  // Cobertura inicial = equipe selecionada
  renderCoveragePanel(selectedRow || ordered[0], selTeam || teamKey(ordered[0]));

  strip.style.display = "flex";
}

function renderProjectStrip(projectId, row){
  if (!$("projectStrip")) return;
  if (!projectId){
    $("projectStrip").style.display = "none";
    return;
  }
  renderProjectRankBoard(projectId, row);
}

function render(){
  const row = currentRow();
  if (!row){ return; }

  const ae = safeParseFloat(row.ae_bn_mean);
  const at = safeParseFloat(row.AT_cont);
  const ac = safeParseFloat(row.AC_cont);
  const dist = parseDistAE(row.dist_AE);

  // KPIs
  setText("kpiAE", fmt(ae, 6));
  setText("kpiAT", fmt(at, 6));
  setText("kpiAC", fmt(ac, 6));

  const aeTier = nearestTier(ae);
  setHTML("kpiAETier", `tier ≈ <span class="mono">${aeTier.tier}</span> (centroide ${fmt(aeTier.centroid,1)})`);

  const atTier = nearestTier(at);
  setHTML("kpiATTier", `tier ≈ <span class="mono">${atTier.tier}</span>`);

  const acTier = nearestTier(ac);
  setHTML("kpiACTier", `tier ≈ <span class="mono">${acTier.tier}</span>`);

  // Charts
  drawBars($("aeBars"), dist, COLORS[0]);
  setText("aeMeta", `team=${row.team_id} | rank=${row.rank_bn}`);

  drawAxis($("axisBars"), at, ac, COLORS[0]);

  // Graph labels
  setText("valAT", `AT_cont=${fmt(at,6)} | tier≈${atTier.tier}`);
  setText("valAC", `AC_cont=${fmt(ac,6)} | tier≈${acTier.tier}`);
  setText("valAE", `AE_mean=${fmt(ae,6)} | tier≈${aeTier.tier}`);

  // ===== Detalhes por nó (VL..VH) =====
  // Se existir dist_Dom/dist_Eco/dist_Ling/dist_AT/dist_AC no CSV, usa.
  // Se não existir: Dom/Eco/Ling usa 1-hot pelo tier; AT/AC usa aproximação pelo contínuo.

  const domTier  = row.Dom ?? row.dom ?? row.DOM ?? row.dominio ?? row.dominio_tier ?? "VH";
  const ecoTier  = row.Eco ?? row.eco ?? row.ECO ?? row.ecossistema ?? row.ecossistema_tier ?? "VH";
  const lingTier = row.Ling ?? row.ling ?? row.LING ?? row.linguagens ?? row.linguagens_tier ?? "VH";

  const distDom = row.dist_Dom ? parseDistAE(row.dist_Dom) : distFromTier(domTier);
  const distEco = row.dist_Eco ? parseDistAE(row.dist_Eco) : distFromTier(ecoTier);
  const distLing = row.dist_Ling ? parseDistAE(row.dist_Ling) : distFromTier(lingTier);

  const distAT = row.dist_AT ? parseDistAE(row.dist_AT) : distFromCont(at);
  const distAC = row.dist_AC ? parseDistAE(row.dist_AC) : distFromCont(ac);
  const distAE2 = dist; // já veio do dist_AE

  // pinta mini gráficos (se os SVGs existirem)
  if ($("distDom"))  drawMiniBars($("distDom"), distDom, COLORS[0]);
  if ($("distEco"))  drawMiniBars($("distEco"), distEco, COLORS[0]);
  if ($("distLing")) drawMiniBars($("distLing"), distLing, COLORS[0]);
  if ($("distAT"))   drawMiniBars($("distAT"), distAT, COLORS[0]);
  if ($("distAC"))   drawMiniBars($("distAC"), distAC, COLORS[0]);
  if ($("distAE2"))  drawMiniBars($("distAE2"), distAE2, COLORS[0]);

  if ($("metaDomDist"))  setText("metaDomDist", row.dist_Dom ? "do CSV" : "1-hot (tier)");
  if ($("metaEcoDist"))  setText("metaEcoDist", row.dist_Eco ? "do CSV" : "1-hot (tier)");
  if ($("metaLingDist")) setText("metaLingDist", row.dist_Ling ? "do CSV" : "1-hot (tier)");
  if ($("metaATDist"))   setText("metaATDist", row.dist_AT ? "do CSV" : "aprox. pelo AT_cont");
  if ($("metaACDist"))   setText("metaACDist", row.dist_AC ? "do CSV" : "aprox. pelo AC_cont");
  if ($("metaAEDist2"))  setText("metaAEDist2", "dist_AE");

  // PC distribution (prefer dist_PC, senão tenta colunas PC_VL..PC_VH, senão usa aproximação a partir de AC)
  let distPC = null;
  if (row.dist_PC) distPC = parseDistAE(row.dist_PC);
  else if (row.PC_VL !== undefined && row.PC_L !== undefined && row.PC_M !== undefined && row.PC_H !== undefined && row.PC_VH !== undefined){
    const nums = [row.PC_VL,row.PC_L,row.PC_M,row.PC_H,row.PC_VH].map(safeParseFloat);
    const s = nums.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
    distPC = (s>0)? nums.map(v=>(Number.isFinite(v)?v:0)/s) : [0,0,0,0,0];
  } else {
    distPC = distAC; // fallback visual
  }

  // Renderiza a rede (com setas + gráficos dentro dos nós)
  renderBNGraph(row, {
    dom: distDom, eco: distEco, ling: distLing, pc: distPC, at: distAT, ac: distAC, ae: distAE2,
    metaDom: row.dist_Dom ? "dist_Dom" : "1-hot",
    metaEco: row.dist_Eco ? "dist_Eco" : "1-hot",
    metaLing: row.dist_Ling ? "dist_Ling" : "1-hot",
    metaPC: row.dist_PC ? "dist_PC" : (row.PC_VL!==undefined ? "PC_VL..PC_VH" : "fallback"),
  });

  // Comparativo do projeto (todas as equipes)
  const pid = (document.getElementById('projectSel') ? document.getElementById('projectSel').value : null);
  if (pid) renderProjectComparison(pid);
  if (pid) renderProjectStrip(pid, row);

// Dom/Eco/Ling discretos (se você adicionar colunas no CSV, eles aparecem)
  const dom = row.Dom ?? row.dom ?? row.DOM ?? row.dominio ?? row.dominio_tier ?? "VH (ex.)";
  const eco = row.Eco ?? row.eco ?? row.ECO ?? row.ecossistema ?? row.ecossistema_tier ?? "VH (ex.)";
  const ling = row.Ling ?? row.ling ?? row.LING ?? row.linguagens ?? row.linguagens_tier ?? "VH (ex.)";
  setText("valDom", String(dom));
  setText("valEco", String(eco));
  setText("valLing", String(ling));
  
  // Table
  renderRowTable(row);
}

function onProjectChange(){
  const p = $("projectSel").value;
  const teams = IDX.teamsByProject.get(p) || [];
  fillSelect($("teamSel"), teams);
  render();
}

function onTeamChange(){
  render();
}

/* =======================
   Load / Save
   ======================= */
function loadFromText(text, name="(arquivo)"){
  try{
    const parsed = parseTextToRows(text);
    if (!parsed.rows.length) throw new Error("Arquivo sem linhas de dados.");
    COLUMNS = parsed.cols;

    // normaliza nomes esperados
    DATA = parsed.rows.map(r => ({
      ...r,
      projeto_id: r.projeto_id ?? r.project_id ?? r.project ?? "",
      team_id: r.team_id ?? r.team ?? r.teamId ?? "",
      team_str: r.team_str ?? r.team ?? "",
      ae_bn_mean: r.ae_bn_mean ?? r.AE_mean ?? r.ae_mean ?? "",
      rank_bn: r.rank_bn ?? r.rank ?? "",
      AT_cont: r.AT_cont ?? r.at_cont ?? r.AT ?? "",
      AC_cont: r.AC_cont ?? r.ac_cont ?? r.AC ?? "",
      dist_AE: r.dist_AE ?? r.AE_dist ?? r.dist_ae ?? "",
    }));

    buildIndex();

    // selects
    fillSelect($("projectSel"), IDX.projects);
    const first = pickFirst();
    $("projectSel").value = first.p;
    onProjectChange();
    $("teamSel").value = first.t;
    render();

    // persist
    localStorage.setItem("bn_dash_last_text", text);
    localStorage.setItem("bn_dash_last_name", name);

    setMessage("msg", `Carregado: ${name} | linhas: ${DATA.length} | projetos: ${IDX.projects.length}`);
  }catch(e){
    console.error(e);
    setMessage("err", "Falha ao ler arquivo: " + (e?.message || e));
  }
}
let DETAILS = new Map();

function makeKey(pid, tid){
  return String(pid ?? "").trim() + "||" + String(tid ?? "").trim();
}

function loadDetailsFromText(text, name="(detalhes)"){
  const parsed = parseTextToRows(text);
  DETAILS = new Map();

  for (const r of parsed.rows){
    const pid = r.projeto_id ?? r.project_id ?? "";
    const tid = r.equipe_id ?? r.team_id ?? "";
    if (!pid || !tid) continue;
    DETAILS.set(makeKey(pid, tid), r);
  }

  localStorage.setItem("bn_dash_details_text", text);
  localStorage.setItem("bn_dash_details_name", name);

  render();
}

function getDetailsForRow(row){
  if (!row) return null;
  return DETAILS.get(makeKey(row.projeto_id, row.team_id)) || null;
}



function loadSample(){
  const sample = [
    "projeto_id\tteam_id\tteam_str\tae_bn_mean\trank_bn\tAT_cont\tAC_cont\tdist_AE",
    "P1\tP1-TEAM0\t[Dev169;Dev27;Dev81;Dev363]\t0.284741\t2\t0.249664\t0.333333\t0.243464,0.591790,0.162324,0.002421,0.000001",
    "P1\tP1-TEAM1\t[Dev10;Dev11;Dev12;Dev13]\t0.612300\t1\t0.700000\t0.500000\t0.010000,0.090000,0.220000,0.420000,0.260000",
    "P2\tP2-TEAM0\t[Dev20;Dev21;Dev22;Dev23]\t0.402000\t3\t0.500000\t0.300000\t0.060000,0.200000,0.500000,0.200000,0.040000"
  ].join("\\n");
  loadFromText(sample, "exemplo.tsv");
}

function clearAll(){
  DATA = []; COLUMNS = []; IDX = {projects:[], teamsByProject:new Map()};
  setHTML("projectSel", ""); setHTML("teamSel", "");
  setText("kpiAE", "—"); setText("kpiAT", "—"); setText("kpiAC", "—");
  setText("kpiAETier", "—"); setText("kpiATTier", "—"); setText("kpiACTier", "—");
  svgClear($("aeBars")); svgClear($("axisBars"));
  setText("valAT", "—"); setText("valAC", "—"); setText("valAE", "—");
  setText("valDom", "—"); setText("valEco", "—"); setText("valLing", "—");
  setHTML("rowTable", "");
  localStorage.removeItem("bn_dash_last_text");
  localStorage.removeItem("bn_dash_last_name");
  setMessage("msg","Dados limpos.");
}

/* im
   Wire up
   ======================= */
$("projectSel").addEventListener("change", onProjectChange);
$("teamSel").addEventListener("change", onTeamChange);

$("fileInput").addEventListener("change", async (ev) => {
  const file = ev.target.files?.[0];
  if (!file) return;
  const text = await file.text();
  loadFromText(text, file.name);
  ev.target.value = ""; // permite reimportar mesmo arquivo
});
document.getElementById("fileDetails").addEventListener("change", async (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const text = await file.text();
  loadDetailsFromText(text, file.name);
  ev.target.value = "";
});


$("btnSample").addEventListener("click", loadSample);
$("btnClear").addEventListener("click", clearAll);

attachNodeTooltips();

// bootstrap: load last if any
const last = localStorage.getItem("bn_dash_last_text");
const lastName = localStorage.getItem("bn_dash_last_name") || "(último arquivo)";
if (last){
  loadFromText(last, lastName);
} else {
  loadSample();
}

function buildDistForRow(row){
  const at = safeParseFloat(row.AT_cont);
  const ac = safeParseFloat(row.AC_cont);
  const distAE = row.dist_AE ? parseDistAE(row.dist_AE) : [0,0,0,0,0];
  const distAT = row.dist_AT ? parseDistAE(row.dist_AT) : distFromCont(at);
  const distAC = row.dist_AC ? parseDistAE(row.dist_AC) : distFromCont(ac);

  const domTier  = row.Dom ?? row.dom ?? row.DOM ?? row.dominio ?? row.dominio_tier ?? "VH";
  const ecoTier  = row.Eco ?? row.eco ?? row.ECO ?? row.ecossistema ?? row.ecossistema_tier ?? "VH";
  const lingTier = row.Ling ?? row.ling ?? row.LING ?? row.linguagens ?? row.linguagens_tier ?? "VH";

  const distDom = row.dist_Dom ? parseDistAE(row.dist_Dom) : distFromTier(domTier);
  const distEco = row.dist_Eco ? parseDistAE(row.dist_Eco) : distFromTier(ecoTier);
  const distLing= row.dist_Ling? parseDistAE(row.dist_Ling): distFromTier(lingTier);

  let distPC = null;
  if (row.dist_PC) distPC = parseDistAE(row.dist_PC);
  else if (row.PC_VL !== undefined && row.PC_L !== undefined && row.PC_M !== undefined && row.PC_H !== undefined && row.PC_VH !== undefined){
    const nums = [row.PC_VL,row.PC_L,row.PC_M,row.PC_H,row.PC_VH].map(safeParseFloat);
    const s = nums.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
    distPC = (s>0)? nums.map(v=>(Number.isFinite(v)?v:0)/s) : [0,0,0,0,0];
  } else distPC = distAC;

  return {distAT, distAC, distAE, distDom, distEco, distLing, distPC};
}

function drawProjectGrouped(svg, teams){
  if (!svg) return;
  svgClear(svg);
  const vb = (svg.getAttribute("viewBox")||"0 0 760 220").split(" ").map(Number);
  const W = vb[2], H = vb[3];

  const padL=110, padR=18, padT=18, padB=34;
  const innerW=W-padL-padR, innerH=H-padT-padB;

  const tiers=["VL","L","M","H","VH"];
  const rowH = innerH/tiers.length;
  const k = teams.length || 1;
  const barH = Math.max(8, (rowH-8)/Math.max(1,k));
  const maxVal = Math.max(0.001, ...teams.flatMap(t=>t.dist));

  // grid + labels
  for (let r=0;r<tiers.length;r++){
    const y = padT + r*rowH + rowH/2 + 4;
    const lab = svgEl("text",{x:padL-10,y,"text-anchor":"end",fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    lab.textContent = tiers[r];
    svg.appendChild(lab);
    svg.appendChild(svgEl("line",{x1:padL,y1:padT+r*rowH,x2:W-padR,y2:padT+r*rowH,stroke:"#eef2f7"}));
  }
  svg.appendChild(svgEl("line",{x1:padL,y1:padT+innerH,x2:W-padR,y2:padT+innerH,stroke:"#d7dde6"}));

  for (let r=0;r<tiers.length;r++){
    for (let i=0;i<k;i++){
      const v = teams[i].dist[r] || 0;
      const bw = (v/maxVal) * innerW;
      const x = padL;
      const y = padT + r*rowH + i*barH + 2;
      svg.appendChild(svgEl("rect",{x,y,width:bw,height:barH-2,rx:"6",ry:"6",fill:teams[i].color,opacity:"0.95"}));
      if (bw>52){
        const txt = svgEl("text",{x:x+bw-6,y:y+barH-6,"text-anchor":"end",fill:"#0b1220","font-size":"20","font-family":"ui-monospace"});
        txt.textContent = (v*100).toFixed(0)+"%";
        svg.appendChild(txt);
      }
    }
  }

  // legend
  let cursor = padL;
  const ly = H-12;
  teams.forEach((t)=>{
    svg.appendChild(svgEl("rect",{x:cursor,y:ly-10,width:10,height:10,rx:"2",ry:"2",fill:t.color}));
    const tt = svgEl("text",{x:cursor+14,y:ly-1,fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    tt.textContent = t.label;
    svg.appendChild(tt);
    cursor += 14 + (t.label.length*7) + 18;
  });
}

function drawProjectGroupedIntoGroup(g, W, H, teams, label){
  const padL=90, padR=16, padT=22, padB=6;
  const innerW=W-padL-padR, innerH=H-padT-padB;
  const tiers=["VL","L","M","H","VH"];
  const rowH = innerH/tiers.length;
  const k = teams.length || 1;
  const barH = Math.max(6, (rowH-6)/Math.max(1,k));
  const maxVal = Math.max(0.001, ...teams.flatMap(t=>t.dist));

  const tt = svgEl("text",{x:12,y:16,fill:"#0b1220","font-size":"20","font-weight":"800","font-family":"ui-sans-serif"});
  tt.textContent = label;
  g.appendChild(tt);

  for (let r=0;r<tiers.length;r++){
    const yMid = padT + r*rowH + rowH/2 + 4;
    const lab = svgEl("text",{x:padL-8,y:yMid,"text-anchor":"end",fill:"#6b7280","font-size":"10","font-family":"ui-monospace"});
    lab.textContent = tiers[r];
    g.appendChild(lab);

    for (let i=0;i<k;i++){
      const v = teams[i].dist[r] || 0;
      const bw = (v/maxVal) * innerW;
      const x = padL;
      const y = padT + r*rowH + i*barH + 1;
      g.appendChild(svgEl("rect",{x,y,width:bw,height:barH-1,rx:"5",ry:"5",fill:teams[i].color,opacity:"0.95"}));
    }
  }
}

function renderProjectComparison(projectId){
  if (!DATA || DATA.length===0) return;
  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||"")===String(projectId));
  if (rows.length===0) return;

  const ordered = rows.slice().sort((a,b)=>{
    const ra = safeParseFloat(a.rank_bn); const rb = safeParseFloat(b.rank_bn);
    if (Number.isFinite(ra) && Number.isFinite(rb)) return ra-rb;
    return String(a.team_id||"").localeCompare(String(b.team_id||""));
  });

  const MAX_TEAMS = 5;
  const teams = ordered.slice(0, MAX_TEAMS).map((r, idx)=>{
    const label = String(r.team_id||`TEAM${idx}`);
    const color = COLORS[idx % COLORS.length];
    const d = buildDistForRow(r);
    return {label,color,...d};
  });

  drawProjectGrouped($("projAT"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAT})));
  drawProjectGrouped($("projAC"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAC})));
  drawProjectGrouped($("projAE"), teams.map(t=>({label:t.label,color:t.color,dist:t.distAE})));

  renderProjectTech(projectId, teams);
}

function renderProjectTech(projectId, teamsPrebuilt=null){
  const rows = DATA.filter(r=>String(r.projeto_id||r.project_id||"")===String(projectId));
  if (rows.length===0) return;

  const teams = teamsPrebuilt ?? rows.map((r, idx)=>{
    const label = String(r.team_id||`TEAM${idx}`);
    const color = COLORS[idx % COLORS.length];
    const d = buildDistForRow(r);
    return {label,color,...d};
  });

  const svg = $("projTech");
  if (!svg) return;
  svgClear(svg);

  const vb = (svg.getAttribute("viewBox")||"0 0 760 260").split(" ").map(Number);
  const W=vb[2], H=vb[3];
  const blocks = [
    {label:"Dom", distKey:"distDom"},
    {label:"Eco", distKey:"distEco"},
    {label:"Ling", distKey:"distLing"},
    {label:"PC", distKey:"distPC"},
  ];
  const blockH = H/blocks.length;

  blocks.forEach((b, bi)=>{
    const g = svgEl("g",{transform:`translate(0,${bi*blockH})`});
    svg.appendChild(g);
    drawProjectGroupedIntoGroup(g, W, blockH, teams.map(t=>({label:t.label,color:t.color,dist:t[b.distKey]})), b.label);
    if (bi<blocks.length-1){
      svg.appendChild(svgEl("line",{x1:12,y1:(bi+1)*blockH,x2:W-12,y2:(bi+1)*blockH,stroke:"#eef2f7"}));
    }
  });

  // legend (limit to 10 to avoid overflow)
  let cursor = 110;
  const ly = H-6;
  teams.slice(0,10).forEach((t)=>{
    svg.appendChild(svgEl("rect",{x:cursor,y:ly-10,width:10,height:10,rx:"2",ry:"2",fill:t.color}));
    const tt = svgEl("text",{x:cursor+14,y:ly-1,fill:"#4b5563","font-size":"20","font-family":"ui-monospace"});
    tt.textContent = t.label;
    svg.appendChild(tt);
    cursor += 14 + (t.label.length*7) + 16;
  });
}

</script>
</body>
</html>
